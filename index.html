<!DOCTYPE html>

<html lang="ru" xmlns:v-on="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="UTF-8">
    <title>Книга рецептов Kotlin</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="main.css"/>

    <script src="syntax.js"></script>
    <link rel="stylesheet" type="text/css" media="screen" href="syntax.css"/>

    <!--<script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.js"></script>-->
</head>

<body>
<h1 class="content-center">Книга рецептов Kotlin</h1>
<div class="content-center"><img alt="Обложка книги" src="img/cover.png"></div>
<p>Ананд Шекхар Рой, Раши Каранпурия</p>
<p>Более 100 рецептов, которые показывают, как создавать надежные мобильные и веб-приложения с помощью Kotlin, Spring
    Boot и Android</p>

<!--Об авторах и рецензентах-->
<div>
    <h2>Об авторах</h2>
    <p><strong>Ананд Шекхар Рой</strong> независимый разработчик Android.
        Его карьера мобильного инженера включает в себя работу в различных стартапах и компаниях, таких как
        ConceptOffice в
        Нидерландах, и стартапы в США.
        Он также является наставником для Associate Android Developer Fast Track program от Google на Udacity, и
        наставником
        команды из 20 разработчиков программного обеспечения, а также является писателем в AndroidPub.
        Вероятно, признание-это та часть книги, которая вас меньше всего интересует. Просто потому, что каждый раз,
        когда вы
        открываете его, это либо думать кого-то другого, кого вы не знаете. Не в этот раз эта книга посвящена только
        таким
        ученикам, как вы, просто потому, что она не ожила бы без вашего желания ее прочитать.</p>

    <p><strong>Раши Каранпурия</strong> является профессиональным разработчиком Android. Она начала свою карьеру,
        работая
        над приложением-кошельком для новозеландского финтех-стартапа.
        Она разработала проекты в различных областях, таких как IOT, AdTech, бизнес, социальные и потоковые приложения.
        За эти годы она приобрела глубокое понимание пользовательского опыта, необходимых для разработки успешного
        мобильного приложения.
        Она сочетает свои навыки проектирования с масштабируемым и поддерживаемым кодом, используя лучшие практики для
        создания качественных продуктов.</p>

    <p>Я хотел бы поблагодарить каждого и каждого члена сообщества разработчиков по всему миру.
        Это единственное сообщество, о котором я знаю, чтобы давать идеи и ресурсы так свободно, не ожидая ничего
        взамен.
        Знаете ли вы Kotlin с открытым исходным кодом? Это дает характер нашего сообщества разработчиков, почему я, кто
        я
        сегодня. Спасибо.</p>

    <h2>Об рецензентах</h2>
    <p><strong>Митчелл Вонг Хо</strong> родился в Йоханнесбурге, Южная Африка, где он получил диплом в области
        электротехники.
        Карьера разработки программного обеспечения Митчелла началась со встроенных систем, и после этого продолжилась в
        области настольного компьютера/сервера Майкрософт.
        Митчелл занимается разработкой приложений на Java с 2000 года J2ME, JEE, desktop и Android, а в последнее время
        пропагандирует Kotlin для Android.</p>
    <hr>
</div>

<!--Введение-->
<div><h1>Введение</h1>
    <p>Данная книга включает в себя примеры реальных проблем, с которыми сталкиваются разработчики, и как Kotlin решает
        их.
        Наряду с этим, книга также поможет разработчикам освоить полезные приемы и концепции, которые могут понадобиться
        при
        написании кода.
        Эта книга также поможет разработчикам раскрыть весь потенциал удивительного языка программирования Kotlin.
        Книга начинается с обзора языка Kotlin и переходит к некоторым прекрасным простым понятиям и функциям, которые
        он
        предлагает.
        Затем она переходит к основам ООП и созданию простых приложений для Android.
        Далее будут рецепты для более сложных понятий, таких как сети, базы данных, архитектуры, ввода-вывода файлов и
        тестирования.
        Книга также будет охватывать некоторые прекрасные возможности Anko, что действительно облегчает некоторые
        сложные
        концепции в разработке Android, что делает разработку быстрее и приятнее.
        В заключении будут несколько разных, но крайне полезных рецептов, которые время от времени могут понадобиться
        разработчикам.</p>
    <hr>
</div>

<!--Для кого предназначена эта книга-->
<div>
    <h1>Для кого предназначена эта книга</h1>
    <p>Эта книга предназначена для начинающих разработчиков Kotlin, которые знают Android и Java, и которые имеют
        хороший
        уровень знаний и понимания цикла разработки Android.
        Читатели знакомы с концепциями разработки Android и понимают потребности тестирования своего кода.
        Они хотят изучить эффективные методы Kotlin, чтобы сделать существующий процесс разработки Android более
        эффективным
        и увлекательным.
        Это не вводная книга для Kotlin, и она предполагает базовое знакомство с Котлином.
        Эта книга призвана помочь разработчикам решить проблемы, с которыми они сталкиваются при работе с Kotlin.</p>
    <hr>
</div>

<!--Что охватывает эта книга-->
<div id="content-book">
    <h1>Что охватывает эта книга</h1>
    <dl>
        <dt>Глава 1</dt>
        <dd>Установка и работа со средой разработки. Создание проекта Kotlin.<br>
            Мы познакомим вас с системой автоматической сборки Gradle и поможем в настройке среды разработки.
        </dd>
        <dt>Глава 2</dt>
        <dd>Поток выполнения.<br>
            Kotlin принес много нового в старые потоки управления, теперь вы можете использовать их в качестве
            выражения.
            Kotlin также ввел мощное "when", которое в основном улучшения "switch" Java.
        </dd>
        <dt>Глава 3</dt>
        <dd>Классы и Объекты.<br>
            Эта глава заложит основу для предстоящей главы по объектно-ориентированному программированию с Kotlin.
        </dd>
        <dt>Глава 4</dt>
        <dd>Функции.</dd>
        <dt>Глава 5</dt>
        <dd>Объектно-ориентированное программирование.<br>
            Эта глава опирается на изучение Главы 3, и будет включать в себя рецепты, которые помогают в ООП.
        </dd>
        <dt>Глава 6</dt>
        <dd>Коллекции.<br>
            Рецепты, которые позволят изучить весь потенциал коллекций в Kotlin.
        </dd>
        <dt>Глава 7</dt>
        <dd>Операции ввода-вывода.<br>
            Рецепты основных операций консольного и файлового ввода-вывода.
        </dd>
        <dt>Глава 8</dt>
        <dd>Anko Commons и функции-расширения<br>
            Рецепты использования библиотеки Anko в Kotlin, для эффективной и быстрой разработки для Android.
        </dd>
        <dt>Глава 9</dt>
        <dd>Anko Layouts<br>
            Рецепты использования библиотеки Anko в Kotlin, для эффективной и быстрой разработки для Android.
        </dd>
        <dt>Глава 10</dt>
        <dd>Базы данных и внедрение зависимостей<br>
            Рецепты для работы с базами данных SQLite в Android.
        </dd>
        <dt>Глава 11</dt>
        <dd>Сеть и параллелизм<br>
            Рецепты, которые помогут разработчикам выполнять сетевые запросы и получать данные по сети.
        </dd>
        <dt>Глава 12</dt>
        <dd>Лямбды и делегаты<br>
            Эта глава раскрывает некоторые из лучших (и сложных) особенностей Kotlin, то есть лямбды и делегаты.
            Он содержит рецепты, чтобы помочь разработчикам начать работу с ними.
        </dd>
        <dt>Глава 13</dt>
        <dd>Тестирование<br>
            Описываются концепции написания тестов в Kotlin, касательно модульных, интеграционных, инструментальных и
            приемочных тестов.
        </dd>
        <dt>Глава 14</dt>
        <dd>Веб-сервисы<br>
            Эта глава расскажет о том, как писать веб-сервисы используя язык Kotlin.
        </dd>
    </dl>
    <hr>
</div>

<!--Как получить максимальную отдачу от этой книги-->
<div>
    <h1>Как получить максимальную отдачу от этой книги</h1>
    <p>Эта книга предполагает знакомство с Java и Android разработкой. Она не является вводной книгой для изучения
        Kotlin.
        Читатели должны использовать Android Studio, потому что многие из рецептов будут сосредоточены на разработке под
        Android.</p>
    <hr>
</div>

<!--Загрузка файлов с примерами кода-->
<div>
    <h1>Загрузка файлов с примерами кода</h1>
    <p>Вы можете скачать файлы с примерами кода для этой книги со своего аккаунта на <a href="http://www.packtpub.com"
                                                                                        target="_blank">www.packtpub.com</a>.
        Если вы приобрели эту книгу в другом месте, вы можете посетить сайт <a href="http://www.packtpub.com/support"
                                                                               target="_blank">www.packtpub.com/support</a>
        и зарегистрируйтесь, чтобы файлы отправлялись вам по электронной почте.
        Файлы с примерами кода можно загрузить, выполнив следующие действия:</p>
    <ol>
        <li>Зарегистрируйтесь на <a href="http://www.packtpub.com" target="_blank">www.packtpub.com</a></li>
        <li>Перейдите на вкладку "SUPPORT"</li>
        <li>Перейдите на "Code Downloads & Errata"</li>
        <li>Введите название книги в поле поиска и следуйте дальнейшим инструкциям.</li>
    </ol>

    <p>После загрузки файла, пожалуйста, убедитесь, что у Вас установлено следующее программное обеспечение для
        распаковки
        скачанного архива с учетом Вашей операционной системы:</p>
    <ul>
        <li>WinRAR/7-Zip для Windows</li>
        <li>Zipeg/iZip/UnRarX для Mac</li>
        <li>7-Zip/PeaZip для Linux</li>
    </ul>
    <p>Архив с файлами примеров кода для этой книги также размещеы на Github по адресу <a
            href="https://gitlab.com/users/aanandshekharroy/projects" target="_blank">https://gitlab.com/users/aanandshekharroy/projects</a>.<br>
        Другие архивы с файлами примеров кода для нашего богатого каталога книг и видео доступны на <a
                href="https://github.com/PacktPublishing/" target="_blank">https://github.com/PacktPublishing/</a>.<br>
        Проверьте их!</p>
    <hr>
</div>

<!--Используемые соглашения-->
<div>
    <h1>Используемые соглашения</h1>
    <p>В этой книге используется ряд текстовых соглашений.</p>
    <p>
        <code>CodeInText</code>
        : Указывает кодовые слова в тексте, имена таблиц базы данных, имена папок и файлов, расширения файлов, пути,
        фиктивные
        URL-адреса, пользовательский ввод, и в Twitter. Вот пример: "соответствующее свойство
        <code>SourceSets</code>
        должно быть обновлено, если не используется соглашение по умолчанию."</p>
    <p>Блок кода оформляется следующим образом:</p>
    <pre>sourceSets {
    main.kotlin.srcDirs += 'src/main/myKotlin'
    main.java.srcDirs += 'src/main/myJava'
}</pre>

    <p>Когда мы хотим обратить ваше внимание на определенную часть блока кода, соответствующие строки или элементы
        выделены
        полужирным шрифтом:</p>
    <pre>sourceSets {
    main.java.srcDirs += <strong>'src/main/kotlin/'</strong>
}</pre>

    <p>Любой ввод или вывод из командной строки записывается следующим образом:</p>
    <pre><strong>$ kotlinc hello.kt -include-runtime -d hello.jar.
$ java -jar hello.jar</strong></pre>
    <p><strong>Bold</strong> : обозначает новое понятие, важное слово, или слова, которые вы видите на экране.
        Например, в тексте выделяются пункты в меню или диалоговых окнах.
        Вот пример: "В окне Выбор целевого объекта развертывания, выберите устройство и нажмите кнопку
        <strong>ОК</strong>."
    </p>

    <p><em>Предупреждения или важные примечания отображаются следующим образом.</em></p>
    <p><em>Советы и рекомендации выглядят следующим образом</em></p>
    <hr>
</div>

<!--Разделы-->
<div>
    <h1>Разделы</h1>
    <p>В этой книге вы найдете несколько заголовков, которые появляются часто (<em>Подготовка, Как это сделать... Как
        это
        работает... Это еще не все...</em>, and <em>См. также...</em>).</p>
    <p>В них даются четкие инструкции о том, как использовать рецепт, используйте эти разделы следующим образом:</p>

    <h3>Подготовка</h3>
    <p>В этом разделе рассказывается, назначение рецепта, описывается как установить необходимое программное обеспечение
        или
        выполнить необходимые предварительные настройки.</p>

    <h3>Как это сделать...</h3>
    <p>Этот раздел содержит шаги, необходимые для выполнения рецепта.</p>

    <h3>Как это работает...</h3>
    <p>Этот раздел обычно состоит из подробного объяснения того, что произошло в предыдущем разделе.</p>

    <h3>Это еще не все...</h3>
    <p>Этот раздел состоит из дополнительной полезной информации.</p>

    <h3>См. также...</h3>
    <p>В этом разделе содержатся полезные ссылки на другую полезную информацию</p>
    <hr>
</div>

<div id="chapters">
    <!--Глава 1-->
    <div id="chapter-1" class="chapter">
        <h1 class="collapsible">Глава 1. Установка и работа с окружением</h1>
        <div>
            <h2>Введение</h2>
            <p>Android-приложения это увлекательная технология. Приложения, разработанные на Android имеют всемирную
                аудиторию.
                Однако она является серьезным вызовом для разработчиков. Проблема заключается в обновлении API,
                платформы и
                поддержке разнообразных возможностей устройств. Например, если вы Android разработчик, вы должны
                полагаться
                на
                Java 6, Если вы хотите поддерживать все Уровни API в Android. Java 6 устарела сейчас настолько, что даже
                его
                преемник, Java 7, сегодня уже устарела. Есть насущная потребность в современном языке для Android, на
                котором
                построена триллионная индустрия. Правда, теперь у нас есть Java 8, но мы можем использовать его, только
                если
                мы
                разрабатываем Android-приложения для API 24-го уровня и выше. Однако это возможно только на 9%
                Android-устройств
                по состоянию на 2017 год.</p>
            <p>Однако не все потеряно, и благодаря JVM мы можем писать Android-приложения используя любой язык, который
                производит совместимый байт-код JVM при компиляции. Поэтому теоретически мы можем использовать Clojure,
                Groovy,
                Scala и Kotlin. Kotlin, это лучшая альтернатива среди всех, почему? Это потому, что в апреле 2017 года
                Google
                объявил Kotlin в качестве официального языка для Android разработки.</p>
            <p>Некоторые из крупнейших технологических компаний, таких как Pinterest, Uber, Atlassian, Coursera и
                Evernote
                теперь используют Kotlin в своих Android-приложениях. Это уже говорит об огромном объеме для Kotlin.
                100%
                совместимость с Android и Java, помогла Kotlin в его принятии. С Kotlin намного проще работать, чем с
                Java,
                и
                кроме Android-приложений Вы также можете создавать веб-приложения на нем. Итак, эта глава познакомит Вас
                с
                Kotlin и поможет вам начать работу с этой удивительной технологией.</p>
            <p>В этой главе мы сначала рассмотрим, как настроить среду для начала работы с Котлином.</p>
            <hr>
            <!--Создание Android-проекта Kotlin-->
            <div id="receipt-1_1" class="receipt">
                <h2 class="collapsible">Создание Android-проекта Kotlin</h2>
                <p>Начать работу с Kotlin очень легко, особенно после того, как Google добавил официальную поддержку
                    языка.
                    Вы
                    можете использовать Kotlin напрямую в Android Studio 3. Android Studio 3 все еще находится в
                    бета-версии
                    на
                    момент написания этой книги. Лучшее в использовании Kotlin для Android является то, что он совместим
                    с
                    существующим кодом, будь то Java или C++. Работая с Kotlin вы поймете, что код в Kotlin является
                    кратким,
                    расширяемым и мощным. Это действительно делает разработку Android более увлекательной и легкой.
                    Давайте
                    посмотрим, как мы можем начать работать в Kotlin, создав проект Kotlin на Android Studio 3.</p>
                <h3>Подготовка</h3>
                <p>Чтобы начать работу, Вам понадобится Android Studio, установленная на ваш компьютер. В Android Studio
                    встроена Android SDK и эмулятор витруального устройства. Убедитесь, что в Вашей системе установлен
                    Java
                    Development Kit. Вам понадобится Android-телефон или эмулятор для отладки проекта. Вам также
                    понадобится
                    по
                    крайней мере одно виртуальное Android-устройство, если у Вас нет Android-телефона.</p>
                <p>Итак, вот перечень необходимого программного обеспечения, которое должно быть установлено, прежде чем
                    перейти
                    к следующему разделу:</p>
                <ul>
                    <li>Java Development Kit (use the latest)</li>
                    <li>Android Studio 3+</li>
                    <li>Android-телефон или виртуальное Android-устройство</li>
                </ul>
                <h3>Как это сделать...</h3>
                <p>Создать проект в Android Studio очень просто, а создание его с поддержкой Kotlin требует один
                    дополнительный
                    щелчок. Вот пошаговый процесс выполнения:</p>
                <ol>
                    <li>В Android Studio в меню выберите <strong>Файл | Создать | Новый проект</strong>. В качестве
                        альтернативы, если вы только
                        что открыли Android Studio и видите окно <strong>"Добро пожаловать в Android Studio"</strong>,
                        нажмите
                        на <strong>Start a new Android Studio project</strong></li>
                    <li>В Мастере создания нового проекта укажите имя приложения и домен компании, установите флажок
                        <strong>Include
                            Kotlin support</strong>. Нажмите кнопку <strong>Next</strong>
                        <img src="img/1.png" alt=""></li>
                    <li>На следующем экране вам будет предложено выбрать целевое устройство и минимальный уровень SDK.
                        Таким
                        образом, в основном, он спрашивает такие вещи, как, "Вы хотите, чтобы приложение запускалось на
                        Android-телефоне, Android-часах или Android-TV", и "Ваше приложение будет работать на версии
                        Android
                        Jelly Bean и выше, или KitKat и выше?"<br>
                        <img src="img/2.png" alt=""></li>
                    <li>На следующем экране, вам будет предложено добавить Activity в проект. Можно пропустить этот шаг
                        и
                        добавить Activity позже, но сейчас просто выберите Basic Activity и нажмите на кнопку
                        <strong>Next</strong>. Если вы дополнительно выбрали другие целевые устройста, вы получите
                        запрос
                        на добавление Activity и для этих устройств.<br>
                        <img src="img/3.png" alt=""></li>
                    <li>Затем вам будет предложено настроить добавленное Activity. В принципе, вам нужно указать имя
                        Activity,
                        Имя макета и заголовок. После этого нажмите на кнопку <strong>Finish</strong>, потому что вы
                        закончили
                        создание Вашего
                        первого проекта Android c Kotlin.
                    </li>
                    <li>Запуск проекта на устройстве: выполните следующие действия:
                        <ol>
                            <li>Подключите устройство к компьютеру кабелем USB.</li>
                            <li>Включите отладку USB на вашем устройстве, перейдя в <strong>Параметры | Параметры
                                разработчика</strong>.
                            </li>
                        </ol>
                        <em>На Android 4.2 и новее, Параметры разработчика скрыты. Чтобы этот пункт меню появился,
                            перейдите
                            в
                            <strong>Настройки | О телефоне</strong> и нажмите на <strong>номер сборки</strong> семь раз.
                            Вернитесь к предыдущему экрану для поиска параметров разработчика.</em></li>
                </ol>
                <p>Теперь в Android Studio нажмите правой кнопкой мыши на модуль приложения в окне проекта, а затем
                    выберите
                    <strong>Run</strong> (или нажмите
                    кнопку <strong>Run</strong> на панели инструментов).</p>
                <p>В окне <strong>Выбор цели развертывания</strong> выберите устройство и нажмите кнопку
                    <strong>ОК</strong>.
                    Через некоторое время вы увидите запущенное приложение на вашем мобильном телефоне или эмуляторе.
                </p>
                <h3>Это еще не все...</h3>
                <p>После нажатия на кнопку <strong>Finish</strong> в окне мастера создания нового проекта, Android
                    Studio
                    создаст ваш проект и выполнит все необходимые настройки. Если вы добавили деятельность, как
                    упоминалось
                    в
                    шаге 4, Вы увидите окно с шаблонным кодом Activity. Это выглядит примерно так:</p>
                <img src="img/4.png" alt="">
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Как использовать Gradle для запуска кода Kotlin-->
            <div id="receipt-1_2" class="receipt">
                <h2 class="collapsible">Как использовать Gradle для запуска кода Kotlin</h2>
                <p><strong>Gradle</strong> сейчас является де-факто инструментом сборки для Android. Она отлично
                    подходит для автоматизации задач, без ущерба для удобства сопровождения, практичности, гибкости,
                    расширяемости, или производительности. В этом рецепте, мы увидим, как использовать Gradle для
                    запуска кода Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA, потому что она предоставляет полное взаимодействие Gradle с
                    Kotlin, и это действительно отличная IDE для работы. Вы также можете использовать для этого Android
                    Studio.</p>
                <h3>Как это сделать...</h3>
                <p>В следующих шагах мы создадим проект Kotlin с системой сборки Gradle. Во-первых, мы выберем опцию
                    <strong>Создать новый проект</strong> из меню. Затем выполним следующие действия:</p>
                <img src="img/5.png">
                <ol>
                    <li>Создание проекта с помощью системы сборки Gradle:<br>
                        <img src="img/6.png"></li>
                    <li>После создания проекта у вас будет <code>build.gradle</code> файл, который будет выглядеть
                        примерно так:
                        <pre>version '1.0-SNAPSHOT'

buildscript {
    ext.kotlin_version = '1.1.4-3'

    repositories {
        mavenCentral()
    }
    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-
        plugin:$kotlin_version"
    }
}
apply plugin: 'java'
apply plugin: 'kotlin'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    compile "org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version"
    testCompile group: 'junit', name: 'junit', version: '4.12'
}

compileKotlin {
    kotlinOptions.jvmTarget = "1.8"
}

compileTestKotlin {
    kotlinOptions.jvmTarget = "1.8"
}</pre>
                    </li>
                    <li>Теперь мы создадим класс HelloWorld, который будет иметь функцию main, являющуюся точкой входа
                        программы:<br>
                        <img src="img/7.png"></li>
                    <li>Было бы здорово запустить этот код напрямую. Для этого мы будем использовать команду <code>gradle
                        run</code>. Однако перед этим нам необходимо подключить плагин, который позволит нам напрямую
                        запустить этот код. Для этого нам нужно добавить две строки в файл <code>build.gradle</code>:
                        <pre>apply plugin: 'application'
mainClassName = "HelloWorldKt"</pre>
                    </li>
                    <li>После этого вы можете ввести <code>gradle run</code> в терминале, чтобы выполнить это файл, и вы
                        увидите выходные данные метода, как показано:
                        <img src="img/8.png"></li>
                </ol>
                <h3>Это еще не все...</h3>
                <p>Структура проекта по умолчанию при создании нового проекта в IntelliJ, как показано:</p>
                <pre>project
    - src
        - main (root)
            - kotlin
            - java</pre>
                <p>Если вы хотите иметь другую структуру проекта, вы должны объявить её в <code>build.gradle</code>. Вы
                    можете
                    сделать это, добавив следующие строки в <code>build.gradle</code>.</p>
                <p>Соответствующее свойство <code>sourceSets</code> должно быть обновлено, если не используется
                    соглашение
                    по
                    умолчанию:</p>
                <pre>sourceSets {
    main.kotlin.srcDirs += 'src/main/myKotlin'
    main.java.srcDirs += 'src/main/myJava'
}</pre>
                <p>Хотя вы можете хранить файлы Kotlin и Java в одном пакете, хорошая практика, это держать их
                    порознь.</p>
                <h3>См. также...</h3>
                <p>Узнайте о том, <em>Как создать исполняемый jar-файл с Gradle и Kotlin</em>, ищите рецепт в этой
                    главе.
                </p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_3" class="receipt">
                <h2 class="collapsible">Как запустить компилятор для класса Kotlin</h2>
                <p>Для любого языка, первым шагом будет изучение работы с компилятором из командной строки, эти знания
                    могут пригодиться. В этом рецепте мы будем запускать Kotlin-программу с помощью командной строки,
                    также мы немного рассмотрим интерактивную оболочку Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Чтобы иметь возможность выполнить этот рецепт, вам потребуется установить на ваш компьютер компилятор
                    Kotlin. Каждый релиз Kotlin поставляется с автономным компилятором. Вы можете найти последнюю версию
                    по ссылке: <a href="https://github.com/JetBrains/kotlin/releases" target="_blank"><code>https://github.com/JetBrains/kotlin/releases</code></a>
                </p>
                <p>Чтобы вручную установить компилятор, распакуйте загруженный архив в каталог, и при необходимости
                    добавьте полный путь к папке bin в переменную окружения <strong>PATH</strong>. Каталог bin содержит
                    скрипты,
                    необходимые для компиляции и запуска Kotlin на Windows, OS X и Linux.</p>
                <h3>Как это сделать...</h3>
                <p>Теперь мы готовы запустить нашу первую программу с помощью командной строки. Сначала, мы создадим
                    простое приложение, которое отображает Hello World! и скомпилируем его:</p>
                <ol>
                    <li>Создайте файл с именем hello.kt и добавьте в него следующие строки кода:
                        <pre>fun main(args: Array&lt;String&gt;) {
    println("Hello, World!")
}</pre>
                    </li>
                    <li>Теперь мы скомпилируем файл, используя следующую команду:
                        <pre><strong>$ kotlinc hello.kt -include-runtime -d hello.jarapply </strong></pre>
                    </li>
                    <li>Теперь мы запускаем приложение, используя следующую команду:
                        <pre><strong>$ java -jar hello.jar</strong></pre>
                    </li>
                    <li>Предположим, вы хотите создать библиотеку, которая может использоваться другими приложениями
                        Kotlin, мы можем просто скомпилировать приложение Kotlin в исполняемый файл <code>.jar</code>
                        без <code>-include-runtime</code>, таким образом, новая команда будет выглядеть так:
                        <pre><strong>$ kotlinc hello.kt -d hello.jar</strong></pre>
                    </li>
                    <li>Теперь давайте проверим интерактивную оболочку Kotlin. Просто запустите Kotlin-компилятор без
                        каких-либо параметров, чтобы увидеть его интерактивную оболочку. Вот как это выглядит:<br>
                        <img src="img/9.png" alt="">
                    </li>
                </ol>
                <p>Надеюсь, вы заметили информацию, которую я всегда игнорирую, команда выхода из интерактивной
                    оболочки: <code>quit</code>, и для вызова справки: <code>help</code>.</p>
                <p>Вы можете запустить любой допустимый код Kotlin в интерактивной оболочке. Например,
                    попробуйте некоторые из следующих команд:</p>
                <ul>
                    <li><code>3*2+(55/5)</code></li>
                    <li><code>println("yo")</code></li>
                    <li><code>println("check this out ${3+4}")</code></li>
                </ul>
                <p>Вот скриншот выполнения предыдущего кода:</p>
                <img src="img/10.png" alt="">
                <h3>Как это работает...</h3>
                <p>Опция <code>-include-runtime</code> создает автономный исполняемый <code>.jar</code>-файл, путем
                    включения в него библиотеки времени выполнения Kotlin. Затем мы используем Java чтобы запустить
                    созданный <code>.jar</code>-файл.</p>
                <p>Опция <code>-d</code> указывает, какие выходные данные компилятора должны вызываться, и может быть
                    именем каталога для файлов класса, или имя <code>.jar</code>-файла. </p>
                <h3>Это еще не все...</h3>
                <p>Kotlin также можно использовать для написания сценариев оболочки. Сценарий оболочки содержит
                    исполняемый код верхнего уровня.</p>
                <p>Файлы скриптов Kotlin имеют расширение <code>.kts</code> в отличие от обычного <code>.kt</code>.</p>
                <p>Чтобы запустить файл сценария, просто передайте компилятору параметр <code>-script</code>:</p>
                <pre><strong>$ kotlinc -script kotlin_script_file_example.kts</strong></pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_4" class="receipt">
                <h2 class="collapsible">Как создать исполняемый jar-файл с Gradle и Kotlin</h2>
                <p>Kotlin отлично подходит для создания небольших утилит командной строки, которые могут быть упакованы
                    и распространены как обычные файлы JAR. В этом рецепте мы увидим, как это сделать с помощью системы
                    сборки Gradle. Система сборки Gradle является одной из самых сложных систем сборки. Это инструмент
                    сборки по умолчанию для Android и предназначен для облегчения написания сложных сценариев,
                    многоязычных сборок с большим количеством зависимостей (типичных для больших проектов). Она
                    автоматизирует ваш проект без ущерба для удобства сопровождения, удобства использования, гибкости,
                    расширяемости и производительности. Мы будем использовать систему сборки Gradle для создания
                    самораспаковывающегося JAR-файла. Этот файл JAR может быть распространен и запущен на любой
                    платформе, поддерживающей Java.</p>
                <h3>Подготовка</h3>
                <p>Вам потребуется IDE (предпочтительно IntelliJ или Android Studio), вы должны указать ей, где
                    находятся Ваши файлы Kotlin. Это можно сделать, в <code>build.gradle</code>-файле, добавив
                    следующее:</p>
                <pre>sourceSets {
    main.java.srcDirs += 'src/main/kotlin/'
}</pre>
                <p>Предыдущие строки необходимы, если файлы Kotlin отделены от пакетов Java. Это необязательно, и Вы
                    можете продолжать работать с файлами Kotlin в пакетах Java, но рекомендуется разделять их.</p>
                <p>Мы напишем очень простую функцию, которая просто напечатает <code>Hello World!</code> при исполнении.
                    Поскольку это будет простая функция, я просто добавляю ее как функцию <code>main()</code> верхнего
                    уровня.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте рассмотрим шаги, с помощью которых мы можем создать исполняемый файл JAR:</p>
                <ol>
                    <li>Мы создадим простой класс <code>HelloWorld.kt</code> который имеет <code>main</code> функцию,
                        выводящую "Hello world!”:
                        <pre>fun main(args:Array&lt;String&gt;){
    println("Hello world")
}</pre>
                    </li>
                    <li>Теперь нам нужно настроить задачу <code>jar</code>, через которую проходит Gradle, чтобы
                        сообщить ей о нашей записи в наш проект. В проекте Java это будет путь к классу, в котором
                        находится наша функция <code>main()</code>, поэтому вам нужно будет добавить эту задачу <code>jar</code>
                        в <code>build.gradle</code>:
                        <pre>jar {
    manifest {
        attributes 'Main-Class': 'HelloWorldKt'
    }
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
}</pre>
                    </li>
                    <li>После добавления предыдущего сниппета для <code>build.gradle</code>, необходимо выполнить
                        следующую команду gradle для создания файла jar:
                        <pre><strong>./gradlew clean jar</strong></pre>
                    </li>
                    <li>Созданный файл jar можно найти в папке <code>build/libs</code>. Теперь вы можете просто
                        запустить <code>java -jar demo.jar</code> для запуска файла JAR.
                    </li>
                </ol>
                <p>После этого можно просмотреть вывод в консоли:</p>
                <img src="img/11.png" alt="">
                <h3>Как это работает...</h3>
                <p>Чтобы сделать исполняемые JAR-файлы, нам нужен файл манифеста с именем <code>MANIFEST.MF</code> в
                    каталоге <code>META-INF</code>. Для этого нам просто нужно указать имя класса Java,
                    который содержит метод <code>main()</code>.</p>
                <p>Можно утверждать, что, хотя у нас нет объявления класса верхнего уровня, мы указываем его как <code>HelloWorldKt</code>
                    в коде для задачи jar:</p>
                <pre>manifest {
    attributes 'Main-Class': 'HelloWorldKt'
}</pre>
                <p>Причина помещения предыдущего блока кода в задачу jar состоит в том, что компилятор Kotlin добавляет
                    все функции верхнего уровня в соответствующие классы для обеспечения обратной совместимости с JVM.
                    Таким образом, имя класса, сгенерированного компилятором Kotlin, будет состоять из имени файла и
                    суффикса <code>Kt</code>, <code>HelloWorldKt</code>.</p>
                <p>Причина, по которой мы добавили <code>{ configurations.compile.collect { it.isDirectory() ? it :
                    zipTree(it) } }</code> в задачу jar в том, что мы хотим, чтобы Gradle скопировал все зависимости
                    JAR. По умолчанию, Gradle (так же как и Maven) упаковывает файлы класса Java в файл JAR,
                    подразумевается, что на этот файл JAR будет ссылаться приложение, где все его зависимости также
                    доступны в classpath загружаемого приложения. Таким образом, указывая эти строки в задаче jar, мы
                    сообщаем gradle, что нужно взять все связанные зависимости этого JAR, и скопировать их как часть
                    самого JAR. В сообществе Java это называется <strong>fat JAR</strong>. В fat JAR все зависимости
                    попадают в classpath загружаемого приложения, поэтому код будет выполнен без проблем. Единственным
                    недостатком создания fat JARs является большой размер файла (что объясняет название), хотя в
                    большинстве ситуаций это не является большой проблемой.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_5" class="receipt">
                <h2 class="collapsible">Чтение консольного ввода в Kotlin</h2>
                <p>Во многих приложениях взаимодействие с пользователем является очень важной частью, и самый простой
                    способ это сделать - прочитать вводимые пользователем данные и выдать на их основе вывод. В этом
                    рецепте
                    мы разберемся в различных способах считывания ввода, а также предоставим вывод в консоли.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить предпочтительную среду разработки, которая компилирует и запускает Kotlin.
                    Можно также использовать командную строку для компиляции и запуска кода Kotlin, для которого
                    необходимо установить компилятор Kotlin вместе с JDK.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте пройдем следующие шаги, с помощью которых мы можем прочитать консольный ввод в Kotlin:</p>
                <ol>
                    <li>Мы начнем с простого и перейдем к более продвинутой логике по мере продвижения вперед.
                        В начале давайте просто выведем строку на консоль:
                        <pre>println("Just a line")</pre>
                    </li>
                    <li>Теперь попробуем получить введеную в консоли строку и вывести ее:
                        <pre>println("Input your first name")
var first_name = readLine()
println("Your first name: $first_name")</pre>
                    </li>
                    <li>Хорошо, как насчет того, чтобы повторить процесс с Int:
                        <pre>println("Hi $first_name, let us have a quick math test. Enter two numbers separated by space.")
val (a, b) = readLine()!!.split(' ').map(String::toInt)
println("$a + $b = ${a+b}")</pre>
                    </li>
                    <li>Теперь давайте попробуем более сложный код, а затем объясним его:
                        <pre>fun main(args: Array&lt;String&gt;) {

    println("Input your first name")
    var first_name = readLine()

    println("Input your last name")
    var last_name = readLine()

    println("Hi $first_name $last_name, let us have a quick math test. Enter two numbers separated by space.")
    val (a, b) = readLine()!!.split(' ').map(String::toInt)

    println("what is $a + $b ?")
    println("Your answer is ${if (readLine()!!.toInt() == (a+b)) "correct" else "incorrect"}")
    println("Correct answer = ${a+b}")

    println("what is $a * $b ?")
    println("Your answer is ${if (readLine()!!.toInt() == (a*b)) "correct" else "incorrect"}")
    println("Correct answer = ${a*b}")

    println("Thanks for participating :)")
}</pre>
                    </li>
                </ol>
                <p>Вот скриншот компиляции и запуска предыдущего кода:</p>
                <img src="img/12.png" alt="">
                <h3>Как это работает...</h3>
                <p>Давайте попробуем разобраться в методах, с помощью которых нам удалось прочитать ввод из консоли.</p>
                <p>За кулисами, <code>Kotlin.io</code> использует <code>java.io</code> для ввода-вывода. Так <code>println</code>
                    использует <code>System.out.println</code>. Использование в Kotlin шаблонов строк и встроенных
                    функций делает написание кода чрезвычайно простым и кратким..</p>
                <p>Это часть кода из Kotlin <code>stdlib</code> используется для консольного ввода/вывода:</p>
                <pre>/** Prints the given message and newline to the standard output stream. */
@kotlin.internal.InlineOnly
public inline fun println(message: Any?) {
    System.out.println(message)
}</pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_6" class="receipt">
                <h2 class="collapsible">Преобразование кода Java в Kotlin и обратно</h2>
                <p>Лучшей частью Kotlin является его совместимость с Java. Кроме того, с IDE на основе IntelliJ, мы
                    можем напрямую конвертировать наш код Java в Kotlin. В этом рецепте мы рассмотрим, как это
                    сделать.</p>
                <h3>Подготовка</h3>
                <p>Для этого рецепта необходима установленная IDE на основе IntelliJ, компилирующая и запускающая Kotlin
                    и Java.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте посмотрим, как преобразовать Kotlin-файл в Java-файл:</p>
                <ol>
                    <li>В IntelliJ IDE откройте Java-файл, который вы хотите преобразовать в Kotlin.</li>
                    <li>Обратите внимание, что он имеет расширение <code>.java</code>. Теперь, в главном меню, нажмите
                        на пункт меню <strong>Code</strong> и выберите опцию <strong>Convert Java File to Kotlin
                            File</strong>. Ваш Java-файл будет преобразован в Kotlin, и расширение файла изменится на
                        <code>.kt</code>.
                        <p>Ниже приведен пример файла Java:</p>
                        <img src="img/13.png" alt="">
                        <p>После преобразования в Kotlin увидим:</p>
                        <img src="img/14.png" alt="">
                    </li>
                    <li>Файл Kotlin можно преобразовать в Java, но лучше, если вы сможете избежать этого или найти
                        альтернативный способ сделать это. Если вам всё таки нужно преобразовать код Kotlin в Java,
                        нажмите <strong>Tools | Kotlin | Show Kotlin Bytecode</strong> в меню:<br>
                        <img src="img/15.png" alt="">
                    </li>
                    <li>После выбора пункта меню <strong>Show Kotlin Bytecode</strong> откроется окно с названием
                        <strong>Kotlin Bytecode</strong>:<br>
                        <img src="img/16.png" alt="">
                    </li>
                    <li>Нажмите на <strong>Decompile</strong>, будет создан файл <code>.java</code>, содержащий
                        декомпилированный байт-код Java из кода Kotlin:<br>
                        <img src="img/17.png" alt="">
                    </li>
                </ol>
                <p>Да, в нем много ненужного кода, которого не было в исходном Java-коде, но так обстоит дело с
                    декомпилированным байт-кодом. На данный момент это единственный способ преобразовать код Kotlin в
                    Java. Скопируйте содержимое декомпилированного файла в <code>.java</code>-файл и удалите ненужный
                    код.</p>
                <h3>Как это работает...</h3>
                <p>Kotlin - это статически типизированный язык программирования, который работает на виртуальной машине
                    Java и компилируется в совместимый с JVM байт-код. Поэтому мы можем конвертировать Java-код в
                    Kotlin, и смешивать Java и Kotlin код вместе. Также Вы можете при необходимости получить Java-код из
                    Kotlin, хотя это не желательно.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_7" class="receipt">
                <h2 class="collapsible">Как написать идиоматический логгер в Kotlin</h2>
                <p>В Kotlin есть несколько отличных мощных функций, которые мы должны использовать для улучшения нашего
                    кода. Они включают в себя переосмысление наших лучших старых практик кодирования. Многие из наших
                    старых методов кодирования могут быть заменены лучшими альтернативами от Kotlin. Одним из них
                    является то, как мы пишем наш логгер. Хотя есть много библиотек, которые обеспечивают
                    функциональность ведения журнала логгирования, мы постараемся создать наш собственный логгер в этом
                    рецепте, используя идиоматический Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте пройдемся по шагам создания идиоматического логгера в Kotlin:</p>
                <ol>
                    <li>Во-первых, давайте посмотрим, как это делается в Java. В Java, используется SLF4J, и считается
                        де-факто стандартом, так что ведение журнала это решаемая проблема в языке Java. Вот как будет
                        выглядеть реализация Java:
                        <pre>private static final Logger logger = LoggerFactory.getLogger(CurrentClass.class);
…
logger.info(“Hi, {}”, name);</pre>
                    </li>
                    <li>С небольшими изменениями он также отлично работает в Kotlin:
                        <pre>val logger = LoggerFactory.getLogger(CurrentClass::class)
…
logger.info(“Hi, {}”, name)</pre>
                    </li>
                </ol>
                <p>Однако, помимо этого, мы можем использовать мощь Kotlin, используя <strong>Делегаты</strong> для
                    журналирования. Мы создадим средство ведения журнала с помощью ключевого слова <code>lazy</code>.
                    Таким образом, мы создадим объект только тогда, когда в нем возникнет необходимость. Делегаты, это
                    отличный способ отложить создание объекта до его использования. Это уменьшает время запуска (что
                    очень важно и ценится в Android). Итак, давайте рассмотрим метод, использующий ленивые делегаты в
                    Котлине:</p>
                <ol>
                    <li>Мы будем использовать встроенный <code>java.util.Logging</code>, но это работает для любой
                        библиотеки ведения журнала. Итак, давайте используем ленивый делегат Котлина, чтобы получить наш
                        логгер:
                        <pre>public fun &lt;R : Any&gt; R.logger(): Lazy&lt;Logger&gt; {
    return lazy { Logger.getLogger(this.javaClass.name) }
}</pre>
                    </li>
                    <li>Теперь в нашем классе, мы можем просто вызвать метод, чтобы получить наш регистратор и
                        использовать его:
                        <pre>class SomeClass {
    companion object { val log by logger() }

    fun do_something() {
        log.info("Did Something")
    }
}</pre>
                    </li>
                </ol>
                <p>При выполнении кода можно увидеть следующие выходные данные:</p>
                <pre><strong>Sep 25, 2017 10:49:00 PM packageA.SomeClass do_something
INFO: Did Something</strong></pre>
                <p>Как мы видим в выходных данных, мы получаем имя класса и имя метода (если вы обращаетесь к логгеру
                    внутри метода).</p>
                <h3>Как это работает...</h3>
                <p>Обратите внимание, мы поместили наш <code>logger</code> в <code>companion object</code>. Причина
                    этого довольно проста, мы хотим иметь только один экземпляр <code>logger</code> на класс.</p>
                <p>Кроме того, <code>logger()</code> возвращает объект-делегат, что означает, что объект будет создан
                    при первом доступе и вернет тот же объект при последующих обращениях.</p>
                <h3>Это еще не все...</h3>
                <p>Anko - это библиотека Android, которая использует Kotlin и упрощает разработку для Android с помощью
                    функций-расширений. Она предоставляет <strong>Anko-logger</strong>, который вы можете использовать,
                    если не хотите писать свой собственный логгер. Он включен в <em>anko-commons</em>, в котором также
                    есть много интересных вещей, которые стоит включить в ваши Android-проекты, использующие Kotlin.</p>
                <p>В Anko стандартная реализация logger будет выглядеть примерно так:</p>
                <pre>class SomeActivity : Activity(), AnkoLogger {
    private fun someMethod() {
        info("London is the capital of Great Britain")
        debug(5) // Метод .toString() будет вызван автоматически
        warn(null) // Будет выведено "null"
    }
}</pre>
                <p>Как вы можете видеть, Вам просто нужно реализовать(имплементировать) AnkoLogger.</p>
                <p>Каждый метод имеет две версии: plain and lazy (inlined):</p>
                <pre>info("String " + "concatenation")</pre>
                <pre>info { "String " + "concatenation" }</pre>
                <p>Лямбда будет вычисляться только если результат <code>Log.isLoggable(tag, Log.INFO)</code> истинен.
                </p>
                <h3>См. также...</h3>
                <p>Дополнительные сведения о делегированных свойствах см. в рецепте <strong>"Работа с делегированными
                    свойствами"</strong>, главы 3 <em>"Классы и объекты"</em>.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_8" class="receipt">
                <h2 class="collapsible">Использование ключевых слов Kotlin в качестве Java-идентификаторов</h2>
                <p>Kotlin был разработан с учетом совместимости. Существующий код в Java может быть вызван из кода
                    Kotlin, но поскольку Java в отличии от Kotlin имеет другие ключевые слова, мы иногда сталкиваемся с
                    проблемами при вызове метода Java с именем, совпадающим с ключевым словом Kotlin. В Kotlin есть
                    обходной путь, который позволяет вызывать метод с именем, представляющим ключевое слово Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Убедитесь, что у вас есть доступ к IDE, или редактору кода, в котором можно писать и запускать
                    код.</p>
                <h3>Как это сделать...</h3>
                <p>Создайте класс Java с именем метода, совпадающим с любым ключевым словом Kotlin. Я использую
                    <code>is</code> в качестве имени метода, мой класс Java выглядит следующим образом:</p>
                <pre>public class ASimpleJavaClass {
    static void is(){
        System.out.print("Nothing fancy here");
    }
}</pre>
                <p>Теперь попробуйте вызвать этот метод из кода Kotlin. Если вы используете какой-либо редактор кода с
                    функцией автозаполнения, он автоматически заключит имя метода в обратные апострофы ( ` ` ):</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    ASimpleJavaClass.`is`()
}</pre>
                <p>Аналогичным образом обрабатываются и другие ключевые слова в Kotlin, которые являются корректными
                    идентификаторами в Java.</p>
                <h3>Как это работает...</h3>
                <p>Согласно документации Kotlin, некоторые ключевые слова Kotlin являются допустимыми идентификаторами в
                    Java: <code>in, object, is</code> и так далее. Если библиотека Java использует ключевое слово Kotlin
                    для имени метода, этот метод можно вызвать экранируя его обратным апострофом <strong>`</strong>.</p>
                <p>Ниже приведены ключевые слова в Kotlin:</p>
                <table>
                    <tr>
                        <td>package</td>
                        <td>as</td>
                        <td>typealias</td>
                        <td>class</td>
                        <td>this</td>
                        <td>super</td>
                        <td>val</td>
                    </tr>
                    <tr>
                        <td>var</td>
                        <td>fun</td>
                        <td>for</td>
                        <td>null</td>
                        <td>true</td>
                        <td>false</td>
                        <td>is</td>
                    </tr>
                    <tr>
                        <td>in</td>
                        <td>throw</td>
                        <td>return</td>
                        <td>break</td>
                        <td>continue</td>
                        <td>object</td>
                        <td>if</td>
                    </tr>
                    <tr>
                        <td>try</td>
                        <td>else</td>
                        <td>while</td>
                        <td>do</td>
                        <td>when</td>
                        <td>interface</td>
                        <td>typeof</td>
                    </tr>
                </table>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_9" class="receipt">
                <h2 class="collapsible">Устранение неоднозначности с помощью ключевого слова "as" для локального
                    переименования импортируемого элемента</h2>
                <p>Импорт библиотеки или класса в коде, это повседневная работа программиста. В настоящее время довольно
                    легко импортировать в код файлы на любом языке, благодаря отличным редакторам кода.</p>
                <p>Однако что произойдет, если попытаться импортировать два класса в файл? Хотя вы всегда должны
                    стараться давать разные имена для разных классов, иногда это неизбежно. Например, в случае различных
                    библиотек, имеющих одинаковое имя для своих классов. В Java, существует обходной путь, вы должны
                    использовать полный квалификатор, который выглядит примерно так:</p>
                <pre>class X {
    com.very.very.long.prefix.bar.Foo a;
    org.other.very.very.long.prefix.baz.Foo b;
...
}</pre>
                <p>Грязно, не правда ли? Теперь давайте посмотрим, как элегантно Kotlin обращается к нему.</p>
                <h3>Подготовка</h3>
                <p>Убедитесь, что у вас есть IDE или редактор кода, в котором можно писать и запускать код. Для
                    тестирования
                    можно создать два класса с одинаковыми именами, но в разных пакетах. См. пример здесь:</p>
                <img src="img/18.png" alt="">
                <h3>Как это сделать...</h3>
                <p>В следующих шагах и примерах мы увидим, как можно устранить неоднозначность классов с одинаковыми
                    именами, используя ключевое слово Kotlin.</p>
                <ol>
                    <li>В Kotlin можно устранить неоднозначность с помощью ключевого слова <code>as</code>, чтобы
                        локально переименовать конфликтующую сущность. В Котлине это будет выглядеть так, как показано:
                        <pre>import foo.Bar // Bar is accessible
import bar.Bar as bBar // bBar stands for 'bar.Bar'</pre>
                    </li>
                    <li>Затем получите доступ к их методам:
                        <pre>Bar.methodOfFooBar()
bBar.methodOfBarBar()</pre>
                    </li>
                </ol>
                <p>Например, рассмотрим использование ключевого слова <code>as</code> для устранения неоднозначности
                    двух классов с одинаковыми именами ( <code>SomeClass.kt</code> ), но в различных пакетах:</p>
                <p><code>SameClass.kt (packageA)</code></p>
                <pre>package packageA

class SameClass {
    companion object {
        fun methodA(){
            println("Method a")
        }
    }
}</pre>
                <p><code>SameClass.kt (packageB)</code></p>
                <pre>package packageB

class SameClass {
    companion object {
        fun methodB(){
            println("Method b")
        }
    }
}</pre>
                <p><code>HelloWorld.kt</code> класс, использующий классы с похожими именами:</p>
                <pre>import packageA.SameClass as anotherSameClass
import packageB.SameClass

fun main(args: Array&lt;String&gt;) {
    anotherSameClass.methodA()
    SameClass.methodB()
}</pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_20" class="receipt">
                <h2 class="collapsible">Выполнение битовых манипуляций в Kotlin</h2>
                <p>Kotlin предоставляет несколько функций (в инфиксной форме) для выполнения побитовых операций и
                    битового сдвига. В этом разделе мы научимся выполнять операции с битами в Kotlin на примерах.</p>
                <p>Побитовые операции и операции битового сдвига, используются только на двух целочисленных типах: Int и
                    Long.</p>
                <h3>Подготовка</h3>
                <p>Вот полный список побитовых операций (доступен только для Int и Long):</p>
                <ul>
                    <li><code>shl(bits)</code> – сдвиг влево с учётом знака (<< в Java)</li>
                    <li><code>shr(bits)</code> – сдвиг вправо с учётом знака (>> в Java)</li>
                    <li><code>ushr(bits)</code> – сдвиг вправо без учёта знака (>>> в Java)</li>
                    <li><code>and(bits)</code> – побитовое И</li>
                    <li><code>or(bits)</code> – побитовое ИЛИ</li>
                    <li><code>xor(bits)</code> – побитовое исключающее ИЛИ</li>
                    <li><code>inv()</code> – побитовое отрицание</li>
                </ul>
                <h3>Как это сделать...</h3>
                <p>Давайте рассмотрим несколько примеров, чтобы понять побитовые операции.</p>
                <h2>OR</h2>
                <p>Функция <code>or</code> сравнивает соответствующие биты двух значений. Если один из двух бит равен 1,
                    он дает 1, а если нет то 0.</p>
                <p>Рассмотрим пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val a=2
    val b=3
    print(a or b)
}</pre>
                <p>Следующий вывод:</p>
                <pre>3</pre>
                <p>Вот объяснение предыдущего примера:</p>
                <p>2 = 10 (Двоичный формат)</p>
                <p>3 = 11 (Двоичный формат)</p>
                <p>Побитовое <code>OR</code> 2 и 3,</p>
                <p>в двоичном формате 10 <code>OR</code> 11</p>
                <p>11 = 3 (Десятичный формат)</p>

                <h2>AND</h2>
                <p>Функция <code>and</code> сравнивает соответствующие биты двух значений. Если один из двух бит равен
                    0,
                    дает 0, если оба бита равны 1, дает 1.</p>
                <p>Рассмотрим пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val a=2
    val b=3
    print(a and b)
}</pre>
                <p>Следующий вывод:</p>
                <pre>2</pre>
                <p>Давайте посмотрим на объяснение:</p>
                <p>2 = 10 (Двоичный формат)</p>
                <p>3 = 11 (Двоичный формат)</p>
                <p>Побитовое <code>AND</code> 2 и 3,</p>
                <p>в двоичном формате 10 <code>AND</code> 11</p>
                <p>10 = 2 (Десятичный формат)</p>

                <h2>XOR</h2>
                <p>Функция <code>xor</code> сравнивает соответствующие биты двух значений. Если соответствующие биты
                    одинаковы, это дает 0, и если они отличаются, дает 1.</p>
                <p>Посмотрите на этот пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val a=2
    val b=3
    print(a xor b)
}</pre>
                <p>Следующий вывод:</p>
                <pre>1</pre>
                <p>Вот объяснение:</p>
                <p>2 = 10 (Двоичный формат)</p>
                <p>3 = 11 (Двоичный формат)</p>
                <p>Побитовое <code>XOR</code> 2 и 3,</p>
                <p>в двоичном формате 10 <code>XOR</code> 11</p>
                <p>01 = 1 (Десятичный формат)</p>

                <h2>INV</h2>
                <p>Функция <code>inv</code> просто инвертирует биты. Если бит равен 1, то он становится равен 0 и
                    наоборот.
                </p>
                <p>Вот пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val a=2
    print(a.inv())
}</pre>
                <p>Следующий вывод:</p>
                <pre>-3</pre>
                <p>Вот объяснение:</p>
                <p>2 = 0000 0010 (Двоичный формат)</p>
                <p>-3 = 1111 1101 (Биты инвертированы)</p>
                <p>Инверсия битов целого числа n равно -(n + 1).</p>

                <h2>SHL</h2>
                <p>Функция <code>shl</code> сдвигает биты влево на указанное количество бит.</p>
                <p>Вот пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    println( 5 shl 0)
    println( 5 shl 1)
    println( 5 shl 2)
}</pre>
                <p>Следующий вывод:</p>
                <pre>5
10
20</pre>
                <p>Вот объяснение:</p>
                <p>5 = 101 (Двоичный формат)</p>
                <p>101 сдвиг влево на 0 бит = 101 (5 в десятичном формате, сдвига нет)</p>
                <p>101 сдвиг влево на 1 бит = 1010 (10 в десятичном формате)</p>
                <p>101 сдвиг влево на 2 бит = 10100 (20 в десятичном формате)</p>

                <h2>SHR</h2>
                <p>Функция <code>shr</code> сдвигает биты вправо на указанное количество бит.</p>
                <p>Вот пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    println( 5 shr 0)
    println( 5 shr 1)
    println( 5 shr 2)
}</pre>
                <p>Следующий вывод:</p>
                <pre>5
2
1</pre>
                <p>Вот объяснение:</p>
                <p>5 = 101 (Двоичный формат)</p>
                <p>101 сдвиг вправо на 0 бит = 101 (5 в десятичном формате, сдвига нет)</p>
                <p>101 сдвиг вправо на 1 бит = 010 (2 в десятичном формате)</p>
                <p>101 сдвиг вправо на 2 бит = 001 (1 в десятичном формате)</p>

                <h2>USHR</h2>
                <p>Функция <code>ushr</code> сдвигает биты вправо на указанное количество бит, заполняя крайние левые
                    биты нулями.</p>
                <p>Вот пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    println( 5 ushr 0)
    println( 5 ushr 1)
    println( 5 ushr 2)
}</pre>
                <p>Следующий вывод:</p>
                <pre>5
2
1</pre>
                <p>Вот объяснение:</p>
                <p>5 = 101 (Двоичный формат)</p>
                <p>101 сдвиг вправо на 0 бит = 101 (5 в десятичном формате, сдвига нет)</p>
                <p>101 сдвиг вправо на 1 бит = 010 (2 в десятичном формате)</p>
                <p>101 сдвиг вправо на 2 бит = 001 (1 в десятичном формате)</p>
                <h3>Как это работает...</h3>
                <p>Побитовые операторы в Kotlin не являются встроенными операторами, как в Java, но их все еще можно
                    использовать в качестве оператора. Почему? Посмотрите на реализацию <code>shr</code>:</p>
                <pre>public infix fun shr(bitCount: Int): Int</pre>
                <p>Вы видите, что метод имеет инфиксную нотацию, которая позволяет ему вызываться как инфиксное
                    выражение.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_21" class="receipt">
                <h2 class="collapsible">Преобразование String в Long, Double, или Int</h2>
                <p>Kotlin упрощает преобразование строк, в другие типы данных, такие как Long, Integer или Double.</p>
                <p>В JAVA, используются статические методы <code>Long.parseLong()</code> , или
                    <code>Long.valueOf()</code>, которые анализируют строковый аргумент, и возвращают его как десятичное
                    число со знаком, также можно преобразовать друге типы данных, такие как Int, Double и Boolean.
                    Давайте посмотрим, как это делается в Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Вам нужен IDE или редактор, для написания и запуска кода Kotlin. В качестве примера мы будем
                    использовать преобразование строки к типу Long. Преобразование к другим типам данных выполняется
                    аналогично.</p>
                <h3>Как это сделать...</h3>
                <p>Чтобы преобразовать строку к типу Long, мы используем метод <code>.toLong()</code> строки. Он
                    анализирует строку и возвращает число Long. Если строка не является допустимым представлением числа
                    метод вызовет исключение <code>NumberFormatException</code>.</p>

                <h2>Преобразование String в Long</h2>
                <p>Вот пример, который показывает преобразование строки в Long:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val str="123"
    print(str.toLong())
}</pre>
                <p>При выполнении предыдущего кода Вы увидите следующие выходные данные:</p>
                <pre>123</pre>
                <p>Если вы не хотите иметь дело с исключениями, вы можете использовать <code>.toLongOrNull()</code>.
                    Этот метод анализирует строку как Long и возвращает результат, или null, если строка не является
                    допустимым представлением числа.</p>

                <h2>Преобразование String в Long с использованием string.toLongOrNull()</h2>
                <p>В этом примере мы увидим, как мы можем преобразовать строку с помощью метода
                    <code>.toLongOrNull()</code>.</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val str="123.4"
    val str2="123"
    println(str.toLongOrNull())
    println(str2.toLongOrNull())
}</pre>
                <p>При запуске предыдущей программы генерируется следующий вывод:</p>
                <pre>null 123</pre>
                <p></p>

                <h2>Преобразование с указанием основания (системы счисления)</h2>
                <p>В предыдущих примерах используется основание (radix) 10. Бывают случаи, когда мы хотим преобразовать
                    строку в Long, но используя другое основание. В оба метода <code>string.toLong()</code> и <code>string.toLongOrNull()</code>,
                    можно передать основание, которое будет использоваться при преобразовании. Давайте посмотрим как это
                    делается:</p>
                <ul>
                    <li><code>string.toLong(radix)</code>:
                        <ul>
                            <li>Преобразовывает строку в <code>[Long]</code> число и возвращает результат</li>
                            <li>Вызывает исключение <code>NumberFormatException</code>, если строка не является
                                допустимым представлением числа
                            </li>
                            <li>Вызывает исключение <code>IllegalArgumentException</code>, когда <code>[radix]</code> не
                                является допустимым основанием для преобразования строки в число
                            </li>
                        </ul>
                    </li>
                    <li><code>string.toLongOrNull(radix)</code>:
                        <ul>
                            <li>Преобразовывает строку в <code>[Long]</code> число и возвращает результат или null, если
                                строка не является допустимым представлением числа
                            </li>
                            <li>Вызывает исключение <code>IllegalArgumentException</code>, когда <code>[radix]</code> не
                                является допустимым основанием для преобразования строки в число
                            </li>
                        </ul>
                    </li>
                </ul>


                <h2>Преобразование String в Long с указанием основания (системы счисления)</h2>
                <p>В предыдущих примерах мы разбирали строки с основанием 10, то есть десятичные. По умолчанию
                    используется основание равное 10, но есть определенные ситуации, когда нам нужно другое основание.
                    Например, в случае разбора строки в виде двоичного или восьмеричного числа. Итак, теперь мы увидим,
                    как работать с основанием, отличным от 10. Хотя вы можете использовать любое допустимое основание,
                    мы покажем наиболее часто используемые примеры, такие как двоичное и восьмеричное.</p>
                <ul>
                    <li><strong>Двоичное</strong>: Так как двоичное число состоит из 0 и 1, то используется основание 2:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val str="11111111"
    print(str.toLongOrNull(2))
}</pre>
                        <p>При запуске предыдущей программы генерируется следующий вывод:</p>
                        <pre>255</pre>
                    </li>
                    <li><strong>Восьмеричное</strong>: Восьмеричная система счисления, или oct для краткости, является
                        системой счисления с основанием равным 8, и использует цифры от 0 до 7. Следовательно, мы будем
                        использовать 8 как основание:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val str="377"
    print(str.toLongOrNull(8))
}</pre>
                        <p>При запуске предыдущей программы генерируется следующий вывод:</p>
                        <pre>255</pre>
                    </li>
                    <li><strong>Десятичное</strong>: Десятичная система содержит 10 чисел (0-9); следовательно, мы будем
                        использовать 10 как основание. Обратите внимание, что основание равное 10, используется по
                        умолчанию в методах без указания основания (<code> .toLong()</code>,
                        <code>.toLongOrNull()</code>):
                        <pre>fun main(args: Array&lt;String&gt;) {
    val str="255"
    print(str.toLongOrNull(10))
}</pre>
                        <p>При запуске предыдущей программы генерируется следующий вывод:</p>
                        <pre>255</pre>
                    </li>
                </ul>

                <h3>Как это работает...</h3>
                <p>Для преобразования Kotlin использует функции-расширения String, такие как <code> .toLong()</code> и
                    <code>.toLongOrNull()</code>. Давайте посмотрим на их реализацию.</p>
                <ul>
                    <li>Для <code>Long</code> используйте:
                        <pre>public inline fun String.toLong(): Long = java.lang.Long.parseLong(this)</pre>
                        <p>Как вы видите, внутри, он также вызывает статический метод Java
                            <code>Long.parseLong(string)</code>, аналогично и с другим типами данных.</p>
                    </li>
                    <li>Для <code>Short</code> используйте:
                        <pre>public inline fun String.toShort(): Short = java.lang.Short.parseShort(this)</pre>
                    </li>
                    <li>Для <code>Int</code> используйте:
                        <pre>public inline fun String.toInt(): Int = java.lang.Integer.parseInt(this)</pre>
                    </li>
                    <li>Для преобразования по основанию используйте:
                        <pre>public inline fun String.toLong(radix: Int): Long = java.lang.Long.parseLong(this, checkRadix(radix))</pre>
                        <p>Метод <code>checkRadix</code> проверяет, является ли переданное основание
                            <code>[radix]</code>, допустимым основанием для преобразования строки в число и число в
                            строку.</p>
                    </li>
                </ul>
                <h3>Это еще не все...</h3>
                <p>Давайте быстро рассмотрим несколько других функций-расширений, предоставляемых Kotlin для
                    преобразования строк:</p>
                <ul>
                    <li><code>toBoolean()</code>: Возвращает <code>true</code> , если содержимое этой строки равно слову
                        <em>true</em>, игнорируя регистр, и <code>false</code> в противном случае.
                    </li>
                    <li><code>toShort()</code>: Преобразует строку в <code>[Short]</code> число и возвращает его.<br>Если
                        строка не является допустимым представлением числа, то вызывает исключение <code>NumberFormatException</code>
                    </li>
                    <li><code>toShort(radix)</code>: Преобразует строку в <code>[Short]</code> число и возвращает
                        его.<br>
                        Если строка не является допустимым представлением числа, то вызывает исключение <code>NumberFormatException.</code><br>
                        Если основание <code>[radix]</code>, не является допустимым основанием для преобразования
                        строки в число, то вызывает исключение <code>IllegalArgumentException</code></li>
                    <li><code>toInt()</code>: Преобразует строку в <code>[Int]</code> число и возвращает его.<br>
                        Если строка не является допустимым представлением числа, то вызывает исключение <code>NumberFormatException</code>
                    </li>
                    <li><code>toIntOrNull()</code>: Преобразует строку в <code>[Int]</code> число и возвращает его, или
                        <code>null</code> если строка не является допустимым представлением числа
                    </li>
                    <li><code>toIntOrNull(radix)</code>: Преобразует строку в <code>[Int]</code> число и возвращает его,
                        или
                        <code>null</code> если строка не является допустимым представлением числа.<br>
                        Если основание <code>[radix]</code>, не является допустимым основанием для преобразования строки
                        в число, то вызывает исключение <code>IllegalArgumentException</code>
                    </li>
                    <li><code>toFloat()</code>: Преобразует строку в <code>[Float]</code> число и возвращает его.<br>
                        Если строка не является допустимым представлением числа, то вызывает исключение <code>NumberFormatException</code>
                    </li>
                    <li><code>toDouble()</code>: Преобразует строку в <code>[Double]</code> число и возвращает его.<br>
                        Если строка не является допустимым представлением числа, то вызывает исключение <code>NumberFormatException</code>
                    </li>
                </ul>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-1_22" class="receipt">
                <h2 class="collapsible">Использование строковых шаблонов в Kotlin</h2>
                <p>Котлин включает в себя продвинутые возможности работы со строками. Одна из действительно интересных
                    функций, это строковые шаблоны. Строковые шаблоны позволяют строкам содержать шаблонные
                    выражения.</p>
                <p>В Java нужно было использовать <strong>StrSubstitutor</strong>
                    (<a target="_blank"
                        href="https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/text/StrSubstitutor.html">https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/text/StrSubstitutor.html</a>)
                    и <code>Map</code>, чтобы получить строковые шаблоны. В Java это выглядит следующим образом:</p>
                <pre>Map&lt;String, String&gt; valuesMap = new HashMap&lt;String, String&gt;();
valuesMap.put("city", "Paris");
valuesMap.put("monument", "Eiffel Tower");
String templateString = "Enjoyed ${monument} in ${city}.";
StrSubstitutor sub = new StrSubstitutor(valuesMap);
String resolvedString =sub.replace(templateString);</pre>
                <p>Kotlin облегчает боль при написании строковых шаблонов и делает его приятным, кратким и намного менее
                    подробным.</p>
                <p>С помощью строковых шаблонов можно внедрить переменную или выражение в строку без объединения строк.
                    Итак, давайте начнем!</p>
                <h3>Как это сделать...</h3>
                <p>В следующих шагах мы узнаем, как использовать строковые шаблоны:</p>
                <ol>
                    <li>В Kotlin выражение в строковом шаблоне начинается со знака <strong>$</strong>.</li>
                    <li>Синтаксис строковых шаблонов следующий:
                        <pre>$variableName</pre>
                        <p>Альтернативный вариант:</p>
                        <pre>${expression}</pre>
                    </li>
                    <li>Давайте рассмотрим несколько примеров:
                        <ul>
                            <li>Рассмотрим пример шаблона строки с переменной:
                                <pre>fun main(args: Array&lt;String&gt;) {
    val foo = 5;
    val myString = "foo = $foo"
    println(myString)
}</pre>
                                <p>Указанный выше код выведет <code>foo = 5</code></p>
                            </li>
                            <li>Рассмотрим пример шаблона строки с выражением:
                                <pre>fun main(arr: Array&lt;String&gt;){
    val lang = "Kotlin"
    val str = "The word Kotlin has ${lang.length} characters."
    println(str)
}</pre>
                            </li>
                            <li>Рассмотрим пример шаблона строки с необработанной строкой:
                                <ul>
                                    <li><strong>Raw string</strong>: Строка, состоящая из нескольких строк без указания
                                        в конце каждой <code>\n</code>. Такие строки заключаются в тройные кавычки ( """
                                        ):
                                        <pre>fun main(args: Array&lt;String&gt;) {
    val a = 5
    val b = 6
    val myString = """
    ${if (a > b) a else b}
"""
    println("Bigger number is: ${myString.trimMargin()}")
}</pre>
                                    </li>
                                </ul>
                                <p>Когда вы запустите программу, она выведет: <code>Bigger number is: 6</code></p>
                            </li>
                        </ul>
                    </li>
                </ol>
                <h3>Как это работает...</h3>
                <p>Использование строкового шаблона с именем переменной довольно просто. Раньше мы объединяли строки, но
                    теперь мы можем просто указать переменную с символом $ перед ней.</p>
                <p>Когда строковой шаблон используется в качестве выражения, выражение внутри <code>${..}</code>
                    вычисляется первым и значение объединяется со строкой. В предыдущем примере (шаблон строки с
                    необработанной строкой) вычисляется выражение <code>${if (a > b) a else b}</code> и его значение, то
                    есть 6, печатается вместе со строкой.</p>
                <h3>Это еще не все...</h3>
                <p>Строковые шаблоны также работают со свойствами и функциями строки. Вот пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val str1="abcdefghijklmnopqrs"
    val str2="tuvwxyz"
    println("str1 equals str2 ? = ${str1.equals(str2)}")
    println("subsequence is ${str1.subSequence(1,4)}")
    println("2nd character is ${str1.get(1)}")
}</pre>
                <p>Выведет:</p>
                <pre>str1 equals str2 ? = false
subsequence is bcd
2nd character is b</pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
        </div>
    </div>

    <!--Глава 2-->
    <div id="chapter-2" class="chapter">
        <h1 class="collapsible">Глава 2. Поток выполнения</h1>
        <div>
            <h2>Введение</h2>
            <p>Потоки управления являются основным строительным блоком любого языка программирования. Kotlin отличается
                от всех остальных тем, что вы можете использовать неокоторые из них в качестве выражения, например
                <code>try - catch</code>, <code>if - else</code>, <code>when</code> и так далее. В этой главе мы
                рассмотрим некоторые из потоков управления, предлагаемых Kotlin, и научимся пользоваться ими. Кроме
                того, мы увидим что они более функциональны чем потоки управления Java. Итак, давайте приступим к
                работе!</p>
            <hr>
            <!--Рецепт-->
            <div id="receipt-2_1" class="receipt">
                <h2 class="collapsible">Назначение результата выражению с помощью ключевого слова if</h2>
                <div>
                    <p>В Kotlin <code>if</code> особенный, поскольку возвращает значение. Мы можем использовать оператор
                        <code>if</code> для присвоения значений. Это устраняет необходимость в тернарном операторе.
                        Давайте посмотрим, как можно использовать оператор <code>if</code> для присвоения значения.</p>
                    <h3>Подготовка</h3>
                    <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели
                        можно также использовать командную строку, для этого необходимо установить компилятор Kotlin
                        вместе с JDK. Я использую командную строку для компиляции и запуска моего кода Kotlin для этого
                        рецепта.</p>
                    <h3>Как это сделать...</h3>
                    <p>Создайте файл и назовите его, <code>ifWithKotlin.kt</code>. Вы можете назвать ее как угодно, имя
                        файла не обязательно должно совпадать с именем класса, как это требует Java. Теперь, чтобы
                        начать
                        работу, необходимо объявить main метод, потому что виртуальная машина Java всегда начинает
                        выполнение, вызывая метод <code>main</code>.</p>
                    <p>Объявление <code>main</code> метода выглядит так:</p>
                    <pre>fun main(args: Array&lt;String&gt;) { }</pre>
                    <ol>
                        <li>Давайте попробуем базовый оператор <code>if</code> традиционным способом, чтобы понять, как
                            он работает:
                            <pre>fun main(args: Array&lt;String&gt;) {
    var x:Int
    if(10>20){
        x = 5
    }else{
        x = 10
    }
    println("$x")
}</pre>
                            <p>В этом блоке кода мы присваиваем значение <code>x</code> в блоке <code>if</code> и <code>else</code>,
                                а затем печатаем его.</p></li>
                        <li>Теперь давайте попробуем то же самое, но используя Kotlin-way:
                            <pre>fun main(args: Array&lt;String&gt;) {
    var x:Int = if(10>20) 5 else 10
    println("$x")
}</pre>
                            <p>В этом блоке кода мы присвоили <code>x</code> значение, возвращаемое блоком <code>if -
                                else</code>. Обратите внимание, что мы использовали оператор if как выражение.</p></li>
                        <li>Посмотрим, что еще можно сделать. В следующем примере мы попытаемся вернуть что-то из
                            выражения с помощью оператора <code>if</code>:
                            <pre>fun main(args: Array&lt;String&gt;) {
    var x:Int
    x = if(10>20) {
        doSomething()
        25
    } else if (12<13) {
        26
    } else {
        27
    }
    println("$x")
}

fun doSomething() {
    var a = 6
    println("$a")
}</pre>
                            <p>Обратите внимание, как мы использовали весь блок <code>if - else</code>. В этом случае
                                блок <code>if</code> возвращает последний оператор блока.</p></li>
                        <li>Наконец, давайте попробуем более сложный пример, используя вложенный <code>if - else</code>.
                            Это поможет нам понять, как значения возвращаются во вложенных <code>if - else</code>:
                            <pre>fun main(args: Array&lt;String&gt;) {
    var x:Int
    x = if(10<20) {
        if(4 == 3){
            56
        } else {
            96
        }
    } else if (12>13) {
        26
    } else {
        27
    }
    println("$x")
}

<strong>//Output: 96</strong></pre>
                            <p>Если в блок <code>if - else</code> (контейнер) вложен другой блок <code>if - else</code>
                                и этот вложенный блок возвращает значение, то это значение передается блоку являющемуся
                                контейнером для вложенного блока, который использует его по своему усмотрению, это проще
                                показать в виде кода. Как вы можете видеть, <code>96</code> возвращается блоком <code>else</code>
                                внутри блока <code>if(10<20)</code>.</p></li>
                        <li>Что произойдет, если блок <code>if - else</code> не является последним оператором, как в
                            этом примере:
                            <pre>fun main(args: Array&lt;String&gt;) {
    var x:Int
    x = if(10<20) {
        if(4 == 3){
            56
        } else {
            96
        }
        565
    } else if (12>13) {
        26
    } else {
        27
    }
    println("$x")
}</pre>
                            <p>Как мы видим, значение возвращаемое вложенным <code>if - else</code>, не используется, и
                                компилятор Kotlin предупреждает нас об этом. Причина этого заключается в том, что блок
                                <code>if - else</code> не является последним оператором родительского блока <code>if -
                                    else</code>, поэтому возвращаемое значение не используется.</p></li>
                    </ol>
                    <img src="img/19.png" alt="">
                    <p>Попробуйте поиграть со значениями и логикой, чтобы увидеть, что еще вы можете сделать с <code>if
                        - else</code>.</p>
                    <p>Главное всегда помнить, что возвращается последний оператор блока <code>if - else</code>, поэтому
                        его можно использовать для присвоения значений любой переменной.</p>
                    <h3>Это еще не все...</h3>
                    <p>Мы использовали шаблоны строк в операторах печати. Обратите внимание, как мы можем получить
                        доступ к переменной, используя символ $ перед именем переменной:</p>
                    <pre>println("$a is a number something”)</pre>
                    <p>Мы также можем поместить часть кода в строки, которые вычисляются и результаты которых
                        объединяются в строку. В этом случае за $ Следует {}, внутри которого мы помещаем наш код:</p>
                    <pre>println("some variable whose value: ${if(a < 100) 25 else 29}")</pre>
                    <p><a href="index.html#content-book">К содержанию...</a></p>
                    <hr>
                </div>
            </div>
            <!--Рецепт-->
            <div id="receipt-2_2" class="receipt">
                <h2 class="collapsible">Использование диапазона с выражением when</h2>
                <p>В Kotlin, <code>when</code> это супер-мощный оператор управления потоком выполнения. Однако это еще
                    не все, что он может сделать. Существует много удивительной логики, которую вы можете построить с
                    помощью оператора <code>when</code>, одним из примеров которого является использование диапазона с
                    оператором <code>when</code>. Мы рассмотрим его в этом рецепте.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую командную строку для компиляции и запуска моего кода Kotlin для этого рецепта.</p>
                <h3>Как это сделать...</h3>
                <p>Во-первых, давайте создадим файл <code>whenWithRanges.kt</code> и выполним следующие действия:</p>
                <ol>
                    <li>Давайте попробуем базовый оператор when, чтобы понять, как он работает:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val x = 12
    when(x){
        12      -> println("x is equal to 12")
        4       -> println("x is equal to 4")
        else    -> println ("no conditions match!")
    }
}</pre>
                        <p>Таким образом, в основном, этот блок кода работает как оператор <code>switch</code>, он также
                            может быть реализован с помощью оператора <code>if</code>.</p>
                    </li>
                    <li>Теперь давайте посмотрим, попадает ли <code>x</code> в диапазон с: <code>1</code> по:
                        <code>10</code> или нет:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val x = 12
    when(x){
        in (1..10)  -> println("x lies between 1 to 10")
        !in (1..10) -> println("x does not lie between 1 to 10")
    }
}</pre>
                    </li>
                    <li>Посмотрим, что еще можно сделать. В следующем примере мы будем работать с различными типами
                        условий, которые можно использовать внутри оператора <code>when</code>:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val x = 10
    when(x){
        magicNum(x) -> println("x is a magic number")
        in (1..10)  -> { println("lies between 1 to 10, value: ${if(x < 20) x else 0}") }
        20, 21      -> println("$x is special and has direct exit access")
        else        -> println("$x needs to be executed")
    }
}

fun magicNum(a: Int): Int {
    return if(a in (15..25)) a else 0
}</pre>
                    </li>
                    <li>Наконец давайте попробуем более сложный пример используя класс данных. В этом примере мы увидим,
                        как использовать, <code>when</code> с объектами:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val x = ob(2, true, 500)
    when(x.value){
        magicNum(x.value)   -> println("$x is a magic number and ${if(x.valid) "valid" else "invalid"}")
        in (1..10)          -> { println("lies between 1 to 10, value: ${if(x.value < x.max) x.value else x.max}") }
        20, 21              -> println("$x is special and has direct exit access")
        else                -> println("$x needs to be executed")
    }
}

data class ob(val value: Int, val valid: Boolean, val max: Int)

fun magicNum(a: Int): Int {
    return if(a in (15..25)) a else 0
}</pre>
                    </li>
                </ol>
                <p>Вот как это выглядит после компиляции и запуска программы:</p>
                <img src="img/20.png" alt="">
                <p>Попробуйте поиграть со значениями и логикой, чтобы увидеть, что еще вы можете сделать с таким
                    небольшим блоком кода в Kotlin, используя, <code>when</code>.</p>
                <h3>Как это работает...</h3>
                <p>В предыдущих примерах, первый пример является самым простым оператором <code>when</code>, мы
                    непосредственно сравниваем значение <code>x</code> с <code>12</code> и <code>4</code>, и если
                    значение не совпадает, мы просто выполняем оператор <code>else</code>. Это похоже на <code>if else
                        if else</code>.</p>
                <p>Во втором примере, в первом операторе блока <code>when</code>, мы проверяем, попадает ли
                    <code>x</code> в диапазон между <code>1</code> и <code>10</code>, а во втором операторе мы
                    проверяем, обратную ситуацию, что <code>x</code> НЕ попадает в диапазон между <code>1</code> и
                    <code>10</code>. Вот как мы работаем с диапазонами <code>when</code>. В принципе, в
                    <code>when</code> мы можем проверить, находится ли <code>x</code> в диапазоне, или содержится в
                    коллекции, используя ключевое слово <code>in</code>. Синтаксис выглядит следующим образом:</p>
                <pre>when(x) {
    In collection_or_range -> // do something
}</pre>
                <p>В третьем примере мы используем функцию <code>magicNum(x)</code>, чтобы проверить, равен ли
                    <code>x</code> результату возвращаемому этой функцией. Таким образом, мы можем использовать
                    выражения и функции вместо констант и диапазонов для сравнения <code>x</code>.</p>
                <p>В четвертом примере мы рассматриваем возможности оператора <code>when</code>, используя класс данных,
                    вместо примитивного типа данных в <code>when</code>. Обратите внимание, как мы получаем доступ ко
                    всем свойствам <code>x</code> внутри, <code>when</code>, выполняем операции с ними.</p>
                <h3>Это еще не все...</h3>
                <p>Мы уже видели, как мы можем использовать шаблоны строк с выражениями в операторах печати. Помните,
                    как мы могли получить доступ к переменной, используя символ $ перед именем переменной:</p>
                <pre>println("$x is a magic number”)</pre>
                <p>Мы также можем поместить часть кода в строку, который вычисляется и результаты подставляются в
                    строку. В этом случае за $ Следует {}, внутри которого мы помещаем наш код:</p>
                <pre>println("lies between 1 to 10, value: ${if(x.value < x.max) x.value else x.max}")</pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-2_3" class="receipt">
                <h2 class="collapsible">Использование when с настраиваемыми объектами</h2>
                <p>В Kotlin, <code>when</code> это уже и так очень функционален, но Вы также можете использовать
                    пользовательские объекты в <code>when</code>. Потрясающе, правда? Давайте приступим к ее реализации.
                </p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую командную строку для компиляции и запуска моего кода Kotlin для этого рецепта.</p>
                <h3>Как это сделать...</h3>
                <p>Создайте файл <code>whenWithObject.kt</code>, а затем, давайте попробуем, <code>then</code> с
                    пользовательским объектом. В этом примере мы создадим объект с некоторыми свойствами и попытаемся
                    сопоставить его в операторе <code>then</code>:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val x = ob(2, true, 500)
    when(x){
        ob(2, true, 500) -> println("equals correct object")
        ob(12, false, 800) -> { println("equals wrong object") }
        else -> println("does not match any object")
    }
}
data class ob(val value: Int, val valid: Boolean, val max: Int)</pre>
                <p>Вот вывод предыдущего блока кода:</p>
                <img src="img/21.png" alt="">
                <p>При попытке сравнить другой тип объекта в <code>then</code> возникает ошибка несовместимых типов:
                    <code>error: incompatible types</code>, поскольку мы пытаемся сравнить объекты разных типов.</p>
                <h3>Как это работает...</h3>
                <p>В Kotlin, <code>then</code> в основном работает с равенством в фоновом режиме, поэтому мы можем
                    сравнивать объекты, пока они одного типа.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-2_4" class="receipt">
                <h2 class="collapsible">Использование try-catch в качестве выражения</h2>
                <p>Исключения в Kotlin похожи и отличаются по сравнению с Java. В Kotlin <code>Throwable</code> является
                    суперклассом всех исключений, и каждое исключение имеет трассировку стека, сообщение и
                    необязательную причину.</p>
                <p>Структура <code>try–catch</code> также аналогична структуре, используемой в Java. В Kotlin вот как
                    выглядит оператор <code>try–catch</code>:</p>
                <pre>try {
    // some code to execute
}
catch (e: SomeException) {
    // exception handler
}
finally {
    // optional finally block
}</pre>
                <p>По крайней мере один блок <code>catch</code> является обязательным, а блок <code>finally</code>
                    необязательным, поэтому его можно опустить.</p>
                <p>В Kotlin <code>try–catch</code> является особенным, поскольку он позволяет использовать его в
                    качестве выражения. В этой статье мы увидим, как можно использовать <code>try–catch</code> в
                    качестве выражения.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую IntelliJ IDE для компиляции и запуска моего кода Kotlin для этого рецепта.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте напишем простую программу, которая принимает число в качестве входных данных и присваивает
                    его значение переменной. Если введенное значение не является числом, мы перехватываем исключение
                    <code>NumberFormatException</code> и присваиваем <code>-1</code> этой переменной:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val str="23"
    val a: Int? = try { str.toInt() } catch (e: NumberFormatException) { -1 }
    println(a)
}</pre>
                <p>Выведет:</p>
                <pre>Output: 23</pre>
                <p>Теперь давайте попробуем что-нибудь некорректное и нарочно попробуем выкинуть исключение:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val str="abc"
    val a: Int? = try { str.toInt() } catch (e: NumberFormatException) { -1 }
    println(a)
}</pre>
                <p>Выведет:</p>
                <pre>Output: -1</pre>
                <p>Использование <code>try–catch</code> поможет вам в крайних случаях, поскольку они могут быть
                    использованы в качестве выражения.</p>
                <h3>Как это работает...</h3>
                <p>Использование <code>try–catch</code> как выражения, приведет к тому, что независимо от того, будет ли
                    вычислено выражение или будет выброшено исключение, значение будет присвоено переменной. </p>
                <p>При использовании <code>try–catch</code> в качестве выражения, возвращается последняя строка блока
                    <code>try</code> или <code>catch</code>. Поэтому в первом примере возвращаемое значение равно 23, а
                    во втором -1.</p>
                <p>Здесь следует отметить, что это не относится к блоку <code>finally</code>, блок <code>finally</code>
                    не повлияет на результат:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val str="abc"
    val a:Int = try {
        str.toInt()
    } catch (e: NumberFormatException) {
        -1
    } finally {
        -2
    }
    println(a)
}</pre>
                <pre>Output: -1</pre>
                <p>Как видите, написание блока <code>finally</code> ничего не меняет.</p>
                <h3>Это еще не все...</h3>
                <p>В Kotlin все исключения непроверяемые, что означает, что нам вообще не нужно применять <code>try–catch</code>.
                    Это сильно отличается от Java, где, если метод выдает исключение, нам нужно окружить его <code>try–catch</code>.
                </p>
                <p>Вот пример операции ввода-вывода в Kotlin:</p>
                <pre>fun fileToString(file: File) : String {
    //readAllBytes может выбросить исключение IOException, но Вы можете не перехватывать его
    fileContent = Files.readAllBytes(file)
    return String(fileContent)
}</pre>
                <p>Как вы можете видеть, нам не нужно оборачивать код, который потенциально может выбросить исключение в
                    <code>try–catch</code>, если мы этого не хотим. В Java мы не могли продолжить работу без обработки
                    этого исключения.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-2_5" class="receipt">
                <h2 class="collapsible">Как написать swap-функцию в Kotlin с помощью функции also</h2>
                <p>Перестановка двух чисел, одна из самых распространенных задач в программировании. Большинство
                    подходов довольно схожи по своей природе: либо вы делаете это с помощью третьей переменной, либо с
                    помощью указателей.</p>
                <p>В Java у нас нет указателей, поэтому в основном мы полагаемся на третью переменную.</p>
                <p>Очевидно, вы можете использовать подход Java в Kotlin:</p>
                <pre>var a = 1
var b = 2
run { val temp = a; a = b; b = temp }
println(a) // print 2
println(b) // print 1</pre>
                <p>Однако в Kotlin есть очень быстрый и интуитивно понятный способ сделать это. Давайте посмотрим
                    как!</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую IntelliJ IDE для компиляции и запуска моего кода Kotlin для этого рецепта.</p>
                <h3>Как это сделать...</h3>
                <p>В Kotlin у нас есть специальная функция, которую мы можем использовать для обмена двух чисел. Вот
                    код:</p>
                <pre>var a = 1
var b = 2
a = b.also { b = a }
println(a) // print 2
println(b) // print 1</pre>
                <p>Мы смогли добиться того же, без использования третьей переменной.</p>
                <h3>Как это работает...</h3>
                <p>Чтобы понять предыдущий пример, нам нужно понять функцию <code>also</code> в Kotlin. Функция <code>also</code>
                    вызывается для объекта, выполняет некоторую операцию и возвращает этот-же объект. Простыми словами,
                    она принимает объект и возвращает тот-же объект.</p>
                <p>Применение функции <code>also</code> к объекту похоже на выражение "do this as well" к этому объекту.
                </p>
                <p>Итак, мы вызвали функцию <code>also</code> для переменной <code>b</code>, сделали операцию (присвоили
                    переменной <code>b</code> значение переменной <code>a</code> ), а затем возвратили тот-же объект
                    <code>b</code>, для которого мы вызывали функцию <code>also</code>:</p>
                <pre>var a = 1
var b = 2
a = b.also {
    b = a // p
    println("it=$it : b=$b : a=$a") // prints it=2:b=1:a=1
}
println(a) // print 2
println(b) // print 1</pre>
                <h3>Это еще не все...</h3>
                <p>Функция <code>apply</code> очень похожа на функцию <code>also</code>, но у них есть тонкое различие.
                    Чтобы понять это, давайте сначала рассмотрим их реализацию:</p>
                <ul>
                    <li>Функция <code>also</code>
                        <pre>public inline fun &lt;T&gt; T.also(block: (T) -> Unit): T { block(this); return this }</pre>
                    </li>
                    <li>Функция <code>apply</code>
                        <pre>public inline fun &lt;T&gt; T.apply(block: T.() -> Unit): T { block(); return this }</pre>
                    </li>
                </ul>
                <p>В <code>also</code>, блок определяется как <code>(T) -> Unit</code>, но он отличается от определения
                    <code>T.() -> Unit</code> в <code>apply()</code>. Это означает, что существует неявное
                    <code>this</code> внутри <code>apply</code> блока. Получить ссылку на сам объект в <code>also</code>
                    можно через <code>it</code>.</p>
                <p>Таким образом, код, использующий <code>also</code> будет выглядеть следующим образом:</p>
                <pre>val result = Dog(12).also { it.age = 13 }</pre>
                <p>Тот же самый код с <code>apply</code> будет выглядеть так:</p>
                <pre>val result2 = Dog(12).apply {age = 13 }</pre>
                <p>Возраст результирующего объекта будет одинаковым в обоих случаях, то есть 13</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-2_6" class="receipt">
                <h2 class="collapsible">Как создать собственное исключение в Kotlin</h2>
                <p>Иногда бывают случаи, когда требуется создать собственное исключение. Собственное исключение
                    называется пользовательским исключением.
                    Пользовательские исключения используются для настройки исключения в соответствии с конкретной
                    потребностью, используя их, вы можете иметь свое собственное исключение и сообщение. В этом рецепте
                    мы увидим, как создать и выбросить пользовательское исключение в Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую IntelliJ IDE для компиляции и запуска моего кода Kotlin для этого рецепта.</p>
                <h3>Как это сделать...</h3>
                <p>Все исключения имеют <code>Exception</code> в качестве суперкласса, поэтому нам нужно расширить этот
                    класс.</p>
                <p>Вот как выглядит наше пользовательское исключение:</p>
                <pre>class CustomException(message:String): Exception(message)</pre>
                <p>Поскольку у суперкласса <code>Exception</code> есть конструктор, который может принимать сообщения,
                    мы передали сообщение с помощью конструктора<code>CustomException</code>.</p>
                <p>Теперь, при помощи <code>throw</code>, Вы можете выбросить исключение, это делается так:</p>
                <pre>throw CustomException("Threw custom exception")</pre>
                <p>На выходе будет что-то вроде этого:</p>
                <img src="img/22.png" alt="">
                <h3>Как это работает...</h3>
                <p>Давайте взглянем на реализацию класса <code>Exception</code>:</p>
                <pre>public class Exception extends Throwable {

    static final long serialVersionUID = -3387516993124229948L;

    public Exception() {}

    public Exception(String var1) {
        super(var1);
    }
    .....</pre>
                <p>Как видите, у нас есть второй конструктор, который принимает <code>String</code> в качестве
                    параметра. В нашем <code>CustomException</code> мы вызвали его, передав сообщение конструктору
                    суперкласса. Кроме того, пользовательское исключение можно создать с пустым конструктором, поскольку
                    <code>Exception</code> также имеет пустой конструктор.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-2_7" class="receipt">
                <h2 class="collapsible">Как сделать цикл с несколькими условиями в Kotlin</h2>
                <p>Условные циклы являются общими для любого языка программирования. Простой пример цикла с несколькими
                    условиями в Java выглядит так:</p>
                <pre>int[] data = {5, 6, 7, 1, 3, 4, 5, 7, 12, 13};

for(int i = 0; i < 10 && i < data[i]; i++){
    System.out.println(data[i]);
}</pre>
                <p>Предыдущий код при выполнении выведет <code>5</code>, <code>6</code> и <code>7</code>. Давайте
                    посмотрим, реализовать цикл с несколькими условиями в Kotlin. Мы рассмотрим функциональный подход в
                    Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую IntelliJ IDE для компиляции и запуска моего кода Kotlin для этого рецепта.</p>
                <h3>Как это сделать...</h3>
                <p>Предыдущий цикл с несколькими условиями может быть реализован в Kotlin следующим образом:</p>
                <pre>val numbers = intArrayOf(5, 6, 7, 1, 3, 4, 5, 7, 12, 13)

(0..9)
    .asSequence()
    .takeWhile { it < numbers[it] }
    .forEach { println("$it - ${numbers[it]}") }</pre>
                <p>Так выглядит гораздо понятнее чище и практичнее.</p>
                <h3>Как это работает...</h3>
                <p>Мы использовали <code>takeWhile</code>, который возвращает последовательность, содержащую первые
                    элементы, пока заданное условие (предикат) истинно. В данном случае <code>i < data[i]</code>.</p>
                <p>Хотя <code>takeWhile</code> возвращает первые элементы, удовлетворяющие заданному условию
                    (предикату), мы можем подумать, что он сначала обработает весь диапазон, а затем перейдет к <code>forEach</code>.
                    Это было бы так, если бы мы не использовали <code>.asSequence()</code>. Но мы преобразовали диапазон
                    в <code>Sequence&lt;T&gt;</code>, и из-за этого он будет обработан лениво.<br>Короче говоря, он не
                    будет обрабатывать весь набор элементов <code>.takeWhile { ... }</code> а будет проверять их один за
                    другим, и после проверки сразу передавать инструкции <code>.forEach { ... }</code>. </p>
                <p>Попробуем разобраться как это работает на примере. Вначале, мы будем работать с жадной версией над
                    <code>Iterable&lt;T&gt;</code>. Это версия, которая сначала полностью выполняет первую функцию перед
                    переходом к следующей:
                </p>
                <pre>(0..9)
    .takeWhile {
        println("Inside takeWhile")
        it < numbers[it]
    }
    .forEach { println("Inside forEach") }</pre>
                <p>Выведет</p>
                <pre>Inside takeWhile
Inside takeWhile
Inside takeWhile
Inside takeWhile
Inside forEach
Inside forEach
Inside forEach</pre>
                <p>Как вы можете видеть, диапазон сначала обрабатывался с помощью <code>takeWhile</code> (который
                    возвращал 0, 1, 2), а затем отправлялся на обработку <code>forEach</code>.</p>
                <p>Теперь давайте посмотрим ленивую версию:</p>
                <pre>(0..9)
    .asSequence()
    .takeWhile {
        println("Inside takeWhile")
        it < numbers[it]
    }
    .forEach { println("Inside forEach") }</pre>
                <pre>Inside takeWhile
Inside forEach
Inside takeWhile
Inside forEach
Inside takeWhile
Inside forEach
Inside takeWhile</pre>
                <p>Как вы можете видеть в предыдущем примере, <code>takeWhile</code> вычисляется только тогда, когда
                    <code>forEach</code> используется для обработки элемента. Такова природа
                    <code>Sequence&lt;T&gt;</code>, которая по возможности выполняется лениво.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
        </div>
    </div>

    <!--Глава 3-->
    <div id="chapter-3" class="chapter">
        <h1 class="collapsible">Глава 3. Классы и объекты</h1>
        <div>
            <h2>Введение</h2>
            <p></p>
            <hr>
            <!--Рецепт-->
            <div id="receipt-3_1" class="receipt">
                <h2 class="collapsible">Обьявление и инициализация членов класса в конструкторе</h2>
                <div>
                    <p></p>
                    <h3>Подготовка</h3>
                    <p>Вам нужна IDE, чтобы писать и выполнять свой код. Я буду использовать IntelliJ IDEA. Мы создадим
                        класс <code>Student</code> со свойством <code>roll_number</code>.</p>
                    <h3>Как это сделать...</h3>
                    <p>Давайте рассмотрим шаги для инициализации членов класса в конструкторе:</p>
                    <ol>
                        <li>Kotlin предоставляет синтаксис, который может инициализировать свойства с гораздо меньшим
                            количеством кода. Вот как выглядит инициализация класса в Kotlin:
                            <pre>class Student(var roll_number:Int, var name:String)</pre>
                        </li>
                        <li>Вам даже не нужно определять тело класса, инициализация свойств происходит только в основном
                            конструкторе (основной конструктор является частью заголовка класса). Очевидно, что вы
                            можете выбрать <code>var</code> или <code>val</code>, в зависимости от того, нужно ли вам
                            сделать свойство изменяемыми или нет. Теперь, если вы попытаетесь создать объект, вы можете
                            сделать это так:
                            <pre>var student_A = Student(1, "Rashi Karanpuria")</pre>
                        </li>
                        <li>Чтобы убедиться, что всё в порядке, давайте попробуем распечатать его свойства, чтобы
                            увидеть, смогли ли мы его инициализировать или нет:
                            <pre>println("Roll number: ${student_A.roll_number} Name:${student_A.name}")</pre>
                            <p>Выведет:</p>
                            <pre>Roll number: 1 Name: Rashi Karanpuria</pre>
                        </li>
                        <li>Однако при желании можно также поместить в конструктор значения по умолчанию:
                            <pre>class Student constructor(var roll_number:Int, var name:String = "Sheldon")</pre>
                        </li>
                        <li>Затем можно создать объекты, такие как:
                            <pre>var student_sheldon = Student(25) // Object with name Sheldon and age 25
var student_amy = Student(25, "Amy") // Object with name Amy and age 25</pre>
                        </li>
                        <li>Если класс имеет первичный конструктор, каждый вторичный конструктор должен вызывать
                            первичный конструктор прямо, или косвенно через другой вторичный конструктор(ы).
                        </li>
                        <li>Мы используем ключевое слово <code>this</code> для вызова другого конструктора этого же
                            класса:
                            <pre>class Person(val name: String) {
    constructor(name: String, lastName: String) : this(name) {// Do something maybe}
}</pre>
                        </li>
                        <li>Может возникнуть ситуация, когда мы должны инициализировать другие сущности класса, не
                            обязательно только свойства. Например необходимо инициализировать подключение к базе данных.
                            В Java это делается в самом конструкторе, в Kotlin для этого есть блок <code>init</code>.
                            Код инициализации можно поместить в блок <code>init</code>:
                            <pre>class Student(var roll_number:Int,var name: String) {
    init {
        logger.info("Student initialized")
    }
}</pre>
                        </li>
                        <li>Иногда мы инициализируем свойства класса путем внедрения зависимостей. Если вы работали с
                            Dagger 2, вы должны быть знакомы с объектами, которые непосредственно вводятся в
                            конструкторы класса. Для этого мы добавляем аннотацию <code>@Inject</code> перед ключевым
                            словом <code>constructor</code>. Когда конструктор имеет аннотацию или модификатор
                            видимости, мы должны явно указывать ключевое слово <code>constructor</code>. Пример
                            ключевого слова <code>constructor</code> приведен ниже:
                            <pre>class Student @Inject constructor(compositeDisposable: CompositeDisposable) { ... }</pre>
                        </li>
                        <li>Здесь мы передаем объект типа <code>CompositeDisposable</code> в конструктор, и так-как для
                            этого мы используем аннотацию (<code>@Inject</code>), нам нужно явно указать ключевое слово
                            <code>constructor</code>.
                        </li>
                        <li>При расширении класса необходимо инициализировать суперкласс. Это также очень просто в
                            Kotlin. Если ваш класс имеет основной конструктор, базовый тип должен быть инициализирован в
                            нем, используя параметры основного конструктора. Вот пример:
                            <pre>class Student constructor(var roll_number: Int, var name: String): Person(name)</pre>
                        </li>
                        <li>Однако иногда класс может не иметь основного конструктора. В этом случае каждый вторичный
                            конструктор должен инициализировать базовый тип с помощью ключевого слова <code>super</code>
                            или может делегировать его другому конструктору. Кроме того, вторичные конструкторы могут
                            вызывать различные конструкторы базового типа:
                            <pre>class Student: Person {
    constructor(name: String): super(name)
    constructor(name: String, roll_number: Int): super(name)
}</pre>
                        </li>
                    </ol>
                    <p><a href="index.html#content-book">К содержанию...</a></p>
                    <hr>
                </div>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_2" class="receipt">
                <h2 class="collapsible">Преобразования одного типа данных в другой</h2>
                <p>В Java для приведения типов мы добавляли нужный тип перед переменными, вот так:</p>
                <pre>String a = Integer.toString(10)</pre>
                <p>Кроме того, в Java, числовые типы напрямую преобразуются в более крупные числовые типы, но в Kotlin
                    эта функция не существует для безопасности типов. Как же мы можем изменить тип объекта на другой в
                    Kotlin? Мы увидим это в этом рецепте.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую онлайн IDE, доступное по адресу <a href="https://try.kotlinlang.org" target="_blank">https://try.kotlinlang.org</a>
                    или <a href="https://play.kotlinlang.org/" target="_blank">https://play.kotlinlang.org</a> для
                    компиляции и запуска кода Kotlin для этого рецепта. Вы также можете использовать среду разработки
                    IntelliJ IDEA.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте по шагам разберемся, как преобразовать один тип данных в другой:</p>
                <ol>
                    <li>Давайте на очень простом примере попытаемся преобразовать <code>Int</code> в <code>Long</code> и
                        <code>Float</code>:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var a = 1
    var b: Float = a.toFloat()
    var c = a.toLong()
    println("$a is Int while $b is Float and $c is Long")
}</pre>
                    </li>
                    <li>Аналогично, <code>Long</code> можно преобразовать в <code>Float</code> и <code>Int</code>:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var a = 1000000000000000000L
    var b: Float = a.toFloat()
    var c = a.toInt()
    println("$a is Long while $b is Float and $c is Integer")
}</pre>
                        <p>Этот код выведет:</p>
                        <pre>1000000000000000000 is Long while 9.9999998E17 is Float and -1486618624 is Integer</pre>
                    </li>
                    <li>Давайте попробуем более интересные преобразования <code>Byte</code>, <code>Int</code> и <code>String</code>
                        :
                        <pre>fun main(args: Array&lt;String&gt;) {
    var a = 15623
    var b: Byte = a.toByte()
    var c = a.toString()
    println("$a is Int while $b is Byte and $c is String")
}</pre>
                    </li>
                </ol>
                <p>Вот список методов, которые можно использовать для преобразования типов в Kotlin:</p>
                <ul>
                    <li><code>toByte()</code> возвращает Byte</li>
                    <li><code>toShort()</code> возвращает Short</li>
                    <li><code>toInt()</code> возвращает Int</li>
                    <li><code>toLong()</code> возвращает Long</li>
                    <li><code>toFloat()</code> возвращает Float</li>
                    <li><code>toDouble()</code> возвращает Double</li>
                    <li><code>toChar()</code> возвращает Char</li>
                    <li><code>toString()</code> возвращает String</li>
                </ul>
                <h3>Как это работает...</h3>
                <p>В принципе, Kotlin является типобезопасным языком и гарантирует, что типы не могут быть неявно
                    преобразованы. Кроме того, тип <code>String</code> не является типом <code>String?</code> это разные
                    типы. Метод преобразования переменной в логический тип отсутствует. Преобразование из большего типа
                    в меньший тип возможно, но может привести к усечению результирующего значения.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_3" class="receipt">
                <h2 class="collapsible">Как проверить тип объекта</h2>
                <p>Часто во время выполнения необходимо проверить, имеет ли объект определенный тип. В Java мы
                    использовали ключевое слово <code>instance</code>, в Kotlin это ключевое слово <code>is</code>.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую онлайн IDE, доступное по адресу <a href="https://try.kotlinlang.org" target="_blank">https://try.kotlinlang.org</a>
                    или <a href="https://play.kotlinlang.org/" target="_blank">https://play.kotlinlang.org</a> для
                    компиляции и запуска кода Kotlin для этого рецепта. Вы также можете использовать среду разработки
                    IntelliJ IDEA.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте посмотрим, как проверить тип объекта в этих шагах:</p>
                <ol>
                    <li>Давайте проверим тип строки и целого числа на очень простом примере используя <code>is</code>:
                        <pre>fun main(args: Array&lt;String&gt;) {

    var a : Any = 1
    var b : Any = "1"

    if (a is String) {
        println("a = $a is String")
    } else {
        println("a = $a is not String")
    }

    if (b is String) {
        println("b = $b is String")
    } else {
        println("b = $b is not String")
    }
}</pre>
                    </li>
                    <li>Аналогично мы можем использовать <code>!is</code> для проверки, что объект НЕ является объектом
                        типа String:
                        <pre>fun main(args: Array&lt;String&gt;) {

    var b : Any = 1
    if (b !is String) {
        println("$b is not String")
    } else {
        println("$b is String")
    }
}</pre>
                    </li>
                </ol>
                <p>Если вы помните, что в Kotlin, в операторе <code>when</code> нам не нужно вводить ключевое слово
                    <code>is</code>, потому что Kotlin имеет функцию умного приведения типа и выдает ошибку, если
                    сравниваемые объекты различных типов.</p>
                <h3>Как это работает...</h3>
                <p>В основном оператор <code>is</code> используется для проверки типа объекта в Котлине и
                    <code>!is</code> это отрицание оператора <code>is</code>.</p>
                <p>Компилятор Kotlin отслеживает неизменяемые значения и безопасно преобразует их там, где это
                    необходимо. Вот как работает умное приведение типа, <code>is</code> - безопасный оператор
                    приведения, в то время как <code>as</code> - небезопасный оператор приведения.</p>
                <h3>Это еще не все...</h3>
                <p>Попробуем пример с оператором <code>as</code>, который используется для приведения типа в Kotlin. Это
                    небезопасный оператор приведения. В следующем примере кода возникает исключение <code>ClassCastException</code>,
                    так-как мы не можем неявно преобразовать целое число в строку:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    var a : Any = 1
    var b = a as String
}</pre>
                <p>С другой стороны, следующий код выполняется успешно так-как переменная <code>a</code>, которая имеет
                    тип <code>Any</code>, может быть преобразована в тип <code>String</code></p>
                <pre>fun main(args: Array&lt;String&gt;) {
    var a : Any = "1"
    var b = a as String
    println(b.length)
}</pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_4" class="receipt">
                <h2 class="collapsible">Как работать с абстрактным классом в Kotlin</h2>
                <p>Абстрактные классы являются классами, которые не могут быть созданы, что означает, что мы не можем
                    создавать объекты абстрактного класса. Основная идея использования абстрактных классов заключается в
                    том, что мы можем наследовать от них. Когда класс наследуется от абстрактного класса, он реализует
                    все абстрактные методы родительского класса.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую онлайн IDE, доступное по адресу <a href="https://try.kotlinlang.org" target="_blank">https://try.kotlinlang.org</a>
                    или <a href="https://play.kotlinlang.org/" target="_blank">https://play.kotlinlang.org</a> для
                    компиляции и запуска кода Kotlin для этого рецепта. Вы также можете использовать среду разработки
                    IntelliJ IDEA.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте посмотрим, как работать с абстрактным классом:</p>
                <ol>
                    <li>Ключевое слово <code>abstract</code> используется для объявления абстрактного класса. Давайте
                        создадим абстрактный класс и попробуем унаследовать от него:
                        <pre>abstract class Mammal {
    abstract fun move(direction: String)
}</pre>
                    </li>
                    <li>Чтобы класс стал подклассом класса млекопитающих <code>Mammal</code>, мы используем оператор
                        <code>:</code>, как показано в следующем примере. Обратите внимание на ключевое слово <code>override</code>,
                        используемое перед реализацией метода суперкласса:
                        <pre>class Dog : Mammal() {
    override fun move(direction: String) { println(direction) }
}</pre>
                    </li>
                    <li>Если мы не хотим, чтобы метод был реализован подклассом, мы не объявляем его
                        <code>abstract</code> или <code>open</code>, как показано в этом примере:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var x = Dog()
    x.move("North")
    println(x.show(123))
}

class Dog : Mammal() {
    override fun move(direction: String) { println(direction) }
}

abstract class Mammal {
    fun show(y: Int): String = y.toString()
    abstract fun move(direction: String)
}</pre>
                    </li>
                    <li>Если мы объявим блоки <code>init</code> в каждом классе, как показано ниже, мы получим вывод,
                        где блок <code>init</code> суперкласса вызывается первым:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var x = Dog()
    x.move("North")
    println(x.show(123))
}

class Dog : Mammal() {
    init { println ("Hey from Dog") }
    override fun move(direction: String) { println(direction) }
}

abstract class Mammal {
    init { println ("Hey from Mammal") }
    fun show(y: Int): String = y.toString()
    abstract fun move(direction: String)
}</pre>
                        <p>Вывод программы таков:</p>
                        <pre>Hey from Mammal
Hey from Dog
North
123</pre>
                    </li>
                </ol>
                <h3>Как это работает...</h3>
                <p>Класс <code>Dog</code> является подклассом <code>Mammal</code> и наследует все его методы. Методы,
                    объявленные как <code>abstract</code>, должны быть реализованы классом <code>Dog</code>. Метод
                    <code>show()</code> находится в <code>Mammal</code>, но может быть вызван объектом Dog, потому что
                    созданный объект имеет тип <code>Mammal</code>.</p>
                <p>Блок <code>init</code> суперкласса вызывается перед подклассом.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_5" class="receipt">
                <h2 class="collapsible">Как выполнить итерацию по свойствам класса в Kotlin</h2>
                <p>Отражения (<code>Reflections</code>) в Kotlin позволяют нам анализировать структуру нашей программы
                    во время выполнения. Это также позволяет нам интроспектировать модификаторы класса, методы и
                    свойства. В этом рецепте мы увидим, как мы можем перебирать свойства класса Kotlin. Итак, давайте
                    приступим к работе!</p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать среду разработки IntelliJ IDEA для написания и запуска кода. Мы создадим класс
                    <code>Student</code>, который будет иметь свойства <code>roll_number</code> и <code>name</code>.
                    Затем мы увидим, как мы можем перебирать эти свойства.</p>
                <p>Если вы не используете IntelliJ IDEA или Android Studio, может потребоваться включить библиотеку
                    <code>reflection</code> в Ваш <code>classpath</code>. Перейдите по адресу: <a
                            href="https://kotlinlang.org/docs/reference/reflection.html" target="_blank">https://kotlinlang.org/docs/reference/reflection.html</a>
                    чтобы узнать об этом больше.</p>
                <h3>Как это сделать...</h3>
                <p>В следующих шагах мы увидим, как выполнить итерацию по свойствам класса:</p>
                <ol>
                    <li>Вот наш класс <code>Student</code> с атрибутами <code>roll_number</code> и
                        <code>full_name</code>:
                        <pre>class Student constructor(var roll_number: Int, var full_name: String)</pre>
                    </li>
                    <li>Теперь используем оператор <code>for</code>, для итерации по свойствам, которые имеет класс:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var student=Student(2013001, "Aanand Shekhar Roy")
    for (property in Student::class.memberProperties) {
        println("${property.name} = ${property.get(student)}")
    }
}</pre>
                        <p>Выведет:</p>
                        <pre>full_name = Aanand Shekhar Roy
roll_number = 2013001</pre>
                    </li>
                </ol>
                <h3>Как это работает...</h3>
                <p>Реализация довольно проста. Мы можем добиться интроспекции свойств класса, так-как мы используем
                    отражения. <code>memberProperties</code> является лишь одной из многих функций <code>KClass</code>.
                </p>
                <p>Следует отметить, что <code>memberProperties</code> возвращает все свойства без расширений,
                    объявленные в этом классе, и все его суперклассах. Считайте, что у нас есть класс
                    <code>Person</code>, как показано ниже:</p>
                <pre>open class Person{
    val isHuman:Boolean = true
}</pre>
                <p>Унаследуем наш класс <code>Student</code> от класса <code>Person</code>. Код, который использовался
                    ранее с <code>memberProperties</code>, выведет:</p>
                <pre>full_name = Aanand Shekhar Roy
roll_number = 2013001
isHuman = true</pre>
                <p>Если вы хотите просто выполнить итерацию только по полям в классе <code>Student</code>, вам
                    понадобится
                    метод <code>declaredMemberProperties</code>. Вот пример:</p>
                <pre>for (property in Student::class.declaredMemberProperties) {
    println("${property.name} = ${property.get(student)}")
}</pre>
                <p>Выведет</p>
                <pre>full_name = Aanand Shekhar Roy
roll_number = 2013001</pre>
                <p>Предыдущие примеры были для класса <code>KClass</code> Kotlin. Предположим, вы хотите перебрать
                    свойства класса <code>Java&lt;T&gt;</code>, тогда вы можете использовать свойство-расширение Kotlin
                    для получения <code>KClass&lt;T&gt;</code>, которое затем Вы можете обработать, например, что-то
                    вроде <code>something.javaClass.kotlin.memberProperties</code>.</p>
                <h3>Это еще не все...</h3>
                <p>Проверьте <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html"
                                target="_blank">список</a> методов, предоставляемых библиотекой <code>Reflection</code>,
                    с помощью которых можно выполнять интроспекцию объектров во время выполнения.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_6" class="receipt">
                <h2 class="collapsible">Как работать со встроенными свойствами</h2>
                <p>В Kotlin есть функции высшего порядка, которые позволяют нам использовать функции в качестве
                    параметров для других функций. Тем не менее, они являются объектами, поэтому работа с ними несет с
                    собой накладные расходы памяти (потому что на каждый экземпляр функции выделяется пространство в
                    куче). Мы можем улучшить ситуацию, используя встроенные функции. Встроенные аннотации означают, что
                    определенная функция, наряду с параметрами функции, будет расширена в месте вызова, это помогает
                    уменьшить издержки вызова.</p>
                <p>Аналогично, ключевое слово <code>inline</code> может использоваться со свойствами и методами доступа
                    к свойствам, не имеющими резервного поля.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую онлайн IDE, доступное по адресу <a href="https://try.kotlinlang.org" target="_blank">https://try.kotlinlang.org</a>
                    или <a href="https://play.kotlinlang.org/" target="_blank">https://play.kotlinlang.org</a> для
                    компиляции и запуска кода Kotlin для этого рецепта. Вы также можете использовать среду разработки
                    IntelliJ IDEA.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте рассмотрим, как работать со встроенными свойствами:</p>
                <ol>
                    <li>Давайте попробуем пример, где мы встраиваем <code>inline</code> метод доступа к свойству в
                        Kotlin:
                        <pre>var x.valueIsMaxedOut: Boolean
inline get() = x.value == CONST_MAX</pre>
                    </li>
                    <li>В этом примере мы просто использовали ключевое слово <code>inline</code> с методом доступа
                        <code>get</code>. Мы также можем объявить методы доступа <code>get</code> и <code>set</code> как
                        <code>inline</code>, сделав все свойство встраиваемым, как показано в этом фрагменте кода:
                        <pre>inline var x.valueIsMaxedOut: Boolean
get() = x.value == CONST_MAX
set(value) {
    // set field here
    println(“Value set!”)
}</pre>
                        <p>В предыдущем фрагменте оба метода доступа встраиваемые.</p>
                    </li>
                    <li>Однако следует иметь в виду, что <code>inline</code> не работает со свойством или методом
                        доступа, если свойство имеет резервное поле или не ссылается на резервное поле. Ниже приведен
                        пример сценария, в котором нельзя использовать <code>inline</code>.
                        <pre>var x.valueIsMaxedOut: Boolean = true
get() = x.value == CONST_MAX
set(value) {
    // set field here
    println(“Value set!”)
}</pre>
                        <p>Еще одна вещь, которую следует иметь в виду, заключается в том, что, хотя встроенные свойства
                            уменьшают нагрузку на вызовы, расширяясь только в месте вызовов, они также увеличивают общий
                            байт-код, поэтому <code>inline</code> не следует использовать с большими функциями или
                            методами доступа.</p>
                    </li>
                </ol>
                <h3>Как это работает...</h3>
                <p>Таким образом, в основном, мы используем <code>inline</code>, когда хотим уменьшить нагрузку на
                    память. Подобно встроенной функции, можно также объявить встроенными свойства или методы доступа к
                    свойствам. Однако следует иметь в виду, что встраивание значительно увеличивает байт-код, поэтому не
                    рекомендуется использовать встроенные функции или методы доступа с большим количеством кода.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_7" class="receipt">
                <h2 class="collapsible">Как работать с вложенным классом</h2>
                <p>В этом рецепте, мы увидим, как использовать вложенные классы в Котлин. Вложенный класс является
                    членом объемлющего класса.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую онлайн IDE, доступное по адресу <a href="https://try.kotlinlang.org" target="_blank">https://try.kotlinlang.org</a>
                    или <a href="https://play.kotlinlang.org/" target="_blank">https://play.kotlinlang.org</a> для
                    компиляции и запуска кода Kotlin для этого рецепта. Вы также можете использовать среду разработки
                    IntelliJ IDEA.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте посмотрим, как работать с вложенным классом</p>
                <ol>
                    <li>Напишем пример вложенного класса в Kotlin:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var a1 = outCl()
    a1.printAB()
    outCl.inCl().printB()
}

class outCl {
    var a = 6
    fun printAB () {
        var b_ = inCl().b
        println ("a = $a and b = $b_ from inside outCl")
    }

    class inCl {
        var b = "9"
        fun printB() { println ("b = $b from inside inCl") }
    }
}</pre>
                        <p>Выведет:</p>
                        <pre>a = 6 and b = 9 from inside outCl
b = 9 from inside inCl</pre>
                    </li>
                    <li>Теперь, напишем пример внутреннего класса. Чтобы объявить вложенный класс как внутренний (<code>inner</code>),
                        используется ключевое слово <code>inner</code>. Внутренний класс может обращаться к членам
                        внешнего класса, поскольку он содержит ссылку на внешний класс:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var a = outCl()
    a.printAB()
    a.inCl().printAB()
}

class outCl {
    var a = 6
    fun printAB () {
        var b_ = inCl().b
        println ("a = $a and b = $b_ from inside outCl")
    }

    inner class inCl {
        var b = "9"
        fun printAB() {
            println ("a = $a and b = $b from inside inCl")
        }
    }
}</pre>
                        <p>Выведет:</p>
                        <pre>a = 6 and b = 9 from inside outCl
a = 6 and b = 9 from inside inCl</pre>
                    </li>
                </ol>
                <h3>Как это работает...</h3>
                <p>Вложенный класс можно создать, просто объявив этот класс внутри другого класса. В этом случае для
                    доступа к вложенному классу создается статическая ссылка, подобная
                    <code>outerClass.innerClass()</code>. Вы можете создать объект вложенного класса, используя <code>outerClass.innerClass()</code>.
                    С другой стороны, внутренний класс создается путем добавления ключевого слова <code>inner</code> к
                    объявлению вложенного класса. В этом случае мы обращаемся к внутреннему классу, как если бы он был
                    членом или внешним классом, то есть, используя объект внешнего класса:</p>
                <pre>var outerClassObject = outerClass()
outerClassObject.innerClass().memberVar</pre>
                <p>Вложенный класс не имеет доступа к членам внешнего класса, так как не имеет ссылки на объект внешнего
                    класса. С другой стороны, внутренний класс может обращаться ко всем членам внешнего класса, так как
                    он имеет ссылку на объект внешнего класса.</p>
                <h3>Это еще не все...</h3>
                <p>Мы также можем создавать анонимные внутренние классы, используя ключевое слово object, например:</p>
                <pre>val customTextTemplateListener = object:ValueEventListener{
    override fun onCancelled(p0: DatabaseError?) {}
    override fun onDataChange(dataSnapshot: DataSnapshot?) {}
}</pre>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_8" class="receipt">
                <h2 class="collapsible">Получение класса в Kotlin</h2>
                <p>В этом рецепте мы рассмотрим способы, с помощью которых мы можем получить ссылку на класс. В первую
                    очередь, мы будем работать с reflection. <code>Reflection</code> - это библиотека, которая
                    предоставляет возможность анализировать код во время выполнения, а не компиляции. В Java мы можем
                    получить класс переменной через <code>getClass()</code>, <code>something.getClass()</code>. Давайте
                    посмотрим, как получить класс переменных в Kotlin.</p>
                <h3>Как это сделать...</h3>
                <ol>
                    <li>В Java эквивалент разрешения имени переменной является метод <code>.getClass()</code>, например
                        <code>something.getClass()</code>. В Kotlin мы можем достичь того же с
                        <code>something.javaClass</code>.
                    </li>
                    <li>Чтобы получить ссылку на класс-отражение, мы использовали <code>something.class</code> в Java,
                        эквивалент в Kotlin <code>something::class</code> возвращает <code>KClass</code>. Особенность
                        <code>KClass</code> - то, что он предоставляет возможности анализа, очень похожие на возможности
                        класса-отражения Java. Обратите внимание, что <code>KClass</code> отличается от объекта <code>Class</code>
                        Java. Если вы хотите получить объект <code>Class</code> Java от <code>KClass</code> Котлина,
                        используйте свойство-расширение <code>.java</code>:
                        <pre>val somethingKClass: KClass&lt;Something&gt; = Something::class
val a: Class&lt;Something&gt; = somethingKClass.java
val b: Class&lt;Something&gt; = Something::class.java</pre>
                    </li>
                    <li>Последний пример будет оптимизирован компилятором, чтобы не выделять промежуточный экземпляр
                        <code>KClass</code>. При использовании Kotlin 1.0 полученный класс Java можно преобразовать в
                        экземпляр <code>KClass</code> путем вызова свойства-расширения <code>.kotlin</code>, например,
                        <code>something.javaClass.kotlin</code></li>
                </ol>
                <h3>Это еще не все...</h3>
                <p>Как было описано выше, класс предоставляет возможности анализа. Вот несколько методов класса:</p>
                <ul>
                    <li><code>isAbstract</code>: True, если класс является абстрактным</li>
                    <li><code>isCompanion</code>: True, если класс является компаньоном</li>
                    <li><code>isData</code>: True, если класс является дата-классом</li>
                    <li><code>isFinal</code>: True, если класс является финализированным</li>
                    <li><code>isInner</code>: True, если класс является внутренним классом</li>
                    <li><code>isOpen</code>: True, если класс открыт</li>
                </ul>
                <p>Перейдите по <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/"
                                   target="_blank">ссылке</a> для полного списка функций, предоставляемых
                    <code>KClass</code>.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_9" class="receipt">
                <h2 class="collapsible">Работа с делегированными свойствами</h2>
                <p>Kotlin 1.1 принес много новшевств, одним из важных, стали делегированные свойства. Существует три
                    типа делегированных свойств:</p>
                <ul>
                    <li><code>lazy</code>: Ленивые свойства вычисляются один раз, при первом использованиии, после этого
                        всегда возвращается уже вычисленное значение, это похоже на кэш
                    </li>
                    <li><code>observable</code>: Слушатель уведомляется при изменении</li>
                    <li><code>map</code>: Свойства хранятся в Map, а не в полях</li>
                </ul>
                <p>В этом рецепте мы рассмотрим, как работать с этими делегатами. Итак, давайте приступим.</p>
                <h3>Подготовка</h3>
                <p>Мы будем работать над кодом Android, поэтому нам потребуется Android Studio 3.</p>
                <h3>Как это сделать...</h3>
                <p>Рассмотрим простой пример делегированного свойства:</p>
                <ol>
                    <li>В начале, мы будем работать со свойством lazy. Проще говоря, этот делегат может приостановить
                        создание объекта до первого обращения к нему. Это действительно важно, когда вы работаете с
                        тяжелыми объектами, создание которых занимает много времени, например, при создании экземпляра
                        базы данных или компонентов dagger. Результат запоминается и возвращается при последующих
                        вызовах <code>getValue()</code> для этого вида делегированного свойства. Давайте рассмотрим
                        пример:
                        <pre>override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val button by lazy { findViewById&lt;Button&gt;(R.id.submit_button) }
    setContentView(R.layout.activity_main)
    button.text="Submit"
}</pre>
                    </li>
                    <li>Выше приведен стандартный метод <code>onCreate</code> активности. Посмотрите внимательно, мы
                        объявили переменную <code>button</code>, перед вызовом метода <code>setContentView (..)</code>.
                        Когда вы запустите код, он отработает без ошибок. Если бы вы не использовали <code>lazy</code>,
                        это бы вызвало исключение <code>NullPointerException</code>, что-то вроде этого:
                        <pre>Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setText(java.lang.CharSequence)' on a null object reference</pre>
                    </li>
                    <li>Переменная <code>button</code> имеет значение <code>null</code> до вызова
                        <code>setContentView</code>.
                        Тем не менее, это не проблема с <code>lazy</code>-объектом <code>button</code>, потому что, хоть
                        мы и объявили его до <code>setContentView</code>, объект <code>button</code> не был создан. Он
                        создается после первого доступа, то есть, когда мы попытались установить у него свойство <code>text</code>.
                    </li>
                    <li>При использованиии делегата-<code>lazy</code>, вам не нужно думать о том, где разместить код для
                        инициализации объекта, а инициализация объекта откладывается до его первого использования.
                    </li>
                </ol>
                <p>Еще одна важная вещь, которую следует отметить, заключается в том, что по умолчанию вычисление <code>lazy</code>-свойств
                    будет синхронизировано, что означает, что значение вычисляется в одном потоке, а остальные потоки
                    будут видеть то же самое значение. Существует три типа инициализации:</p>
                <ul>
                    <li><code>LazyThreadSafetyMode.SYNCHRONIZED</code>: Это режим по умолчанию, который гарантирует, что
                        только один поток может инициализировать экземпляр.
                    </li>
                    <li><code>LazyThreadSafetyMode.PUBLICATION</code>: В этом режиме инициализацию могут выполнять
                        несколько потоков.
                    </li>
                    <li><code>LazyThreadSafetyMode.NONE</code>: Этот режим используется, когда мы уверены, что
                        инициализация произойдет только в одном потоке. Например, в случае Android мы можем быть
                        уверены, что представления будут инициализированы только потоком пользовательского интерфейса.
                        Этот режим не гарантирует потокобезопасность, но значительно снижает накладные расходы.
                    </li>
                </ul>
                <p>Другим полезным делегатом является <code>observable</code>-делегат. Этот делегат помогает нам
                    отслеживать любые изменения свойства. Например, давайте рассмотрим очень простую реализацию <code>observable</code>
                    делегата:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val paris=Travel()
    paris.placeName="Paris"
    paris.placeName="Italy"
}

class Travel {
    var placeName: String by Delegates.observable("<>") { property, oldValue, newValue -> println("oldValue = $oldValue, newValue = $newValue") }
}</pre>
                <p>Выведет</p>
                <pre>oldValue = <>, newValue = Paris
oldValue = Paris, newValue = Italy</pre>
                <p>Как мы видим, наблюдаемый делегат принимает две вещи: значение по умолчанию (которое мы указали как
                    "<>" ) и обработчик, который вызывается всякий раз, когда это свойство изменяется.</p>
                <p>Давайте теперь работать с <code>vetoable</code>-делегатом. Это очень похоже на наблюдаемый делегат,
                    но с ним мы можем "наложить вето" на модификацию. Давайте рассмотрим пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val paris=Travel()
    paris.placeName="Paris"
    paris.placeName="Italy"
    println(paris.placeName)
}

class Travel {
    var placeName:String by Delegates.vetoable("<>"){ property, oldValue, newValue -> if(!newValue.equals("Paris")) { return@vetoable false } true }
}</pre>
                <p>Выведет</p>
                <pre>Paris</pre>
                <p>В предыдущем примере, если <code>newValue</code> не равно <code>"Paris"</code>, Мы вернем
                    <code>false</code>, и изменение будет прервано. Если вы хотите, чтобы изменение произошло,
                    необходимо возвратить <code>true</code> из конструкции.</p>
                <p>Иногда вы динамически создаете объект на основе значений, например, в случае разбора JSON. В этом
                    случае для свойства можно использовать <code>map</code>-делегат. Давайте посмотрим пример:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val paris=Travel(mapOf("placeName" to "Paris"))
    println(paris.placeName)
}

class Travel(val map:Map&lt;String, Any?&gt;) {
    val placeName: String by map
}</pre>
                <p>Выведет</p>
                <pre>Paris</pre>
                <p>Чтобы заставить его работать с <code>var</code>-свойствами, необходимо использовать
                    <code>MutableMap</code>. В этом случае предыдущий пример будет выглядеть так:</p>
                <pre>fun main(args: Array&lt;String&gt;) {
    val paris=Travel(mutableMapOf("placeName" to "Paris"))
    println(paris.placeName)
}

class Travel(val map:MutableMap&lt;String, Any?&gt;) {
    var placeName: String by map
}</pre>
                <p>Конечно, на выходе будет то же самое.</p>
                <h3>Это еще не все...</h3>
                <p>Наблюдаемое делегированное свойство может широко использоваться в адаптерах. Адаптеры используются
                    для заполнения данных в каком-либо списке. Обычно, когда данные обновляются, мы просто обновляем
                    список переменных-членов в адаптере, а затем вызываем <code>notifyDatasetChanged()</code>. С помощью
                    <code>observable</code> и <code>DiffUtils</code>, мы можем обновить только свойства, которые
                    фактически изменены, вместо обновления всех свойств. Это гораздо эффективнее.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-3_10" class="receipt">
                <h2 class="collapsible">Работа с перечислениями</h2>
                <p>Перечисления используются, когда переменная может принимать только одно из небольшого набора
                    возможных значений. Например направление: "Север", "Юг", “Восток”и "Запад". С помощью перечислений
                    можно избежать ошибок при передаче недопустимых констант, а также задокументировать допустимые
                    значения. В этом рецепте, мы увидим, как использовать перечисления в Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать среду разработки IntelliJ IDEA для написания и запуска кода. Во-первых, мы
                    создадим простое типобезопасное перечисление <code>Direction</code>, с членами <code>NORTH</code>,
                    <code>SOUTH</code>, <code>EAST</code>, и <code>WEST</code> (представляющие четыре стороны света).
                </p>
                <h3>Как это сделать...</h3>
                <p>Рассмотрим пример <code>enum</code>-класса:</p>
                <ol>
                    <li>В этом примере мы создадим перечисление <code>Direction</code>. Будем считать, направлений всего
                        четыре:
                        <pre>enum class Direction { NORTH,SOUTH,EAST,WEST }

fun main(args: Array&lt;String&gt;) {
    var north_direction = Direction.NORTH
    if(north_direction == Direction.NORTH){
        println("Going North")
    } else {
        println("No idea where you're going!")
    }
}</pre>
                    </li>
                    <li>Как вы можете видеть, переменная <code>north_direction</code> может просто принимать значения из
                        предопределенных констант в <code>enum</code>-классе <code>Direction</code>.
                    </li>
                    <li>Мы также можем инициализировать перечисления значениями по умолчанию:
                        <pre>enum class Direction(var value:Int) { NORTH(1),SOUTH(2),EAST(3),WEST(4) }

fun main(args: Array&lt;String&gt;) {
    var north_direction = 1
    if(north_direction == Direction.NORTH.value){
        println("Going North")
    } else {
        println("No idea where you're going!")
    }
}

//Output: Going North</pre>
                    </li>
                </ol>
                <h3>Это еще не все...</h3>
                <p>Настоятельно рекомендуется не использовать перечисления в проектах Android. По словам инженеров
                    Google, добавление одного перечисления увеличит размер примерно в 13 раз по сравнению с
                    окончательным файлом DEX. Это также создает проблему издержек времени выполнения, и ваше приложение
                    потребует больше места.</p>
                <p>В документации Android говорится следующее:</p>
                <em><q>Перечисления часто требуют в два раза больше памяти, чем статические константы. Вы должны строго
                    избегать использования перечислений на Android.</q></em>
                <p>Однако, если вы хотите использовать удобство перечислений, вы можете использовать библиотеку
                    аннотаций Android, в которой есть аннотации <code>TypeDef</code>, но, к сожалению, это не
                    поддерживалось Kotlin во время написания этой книги, поэтому мы надеемся, что она будет добавлена в
                    будущих версиях Kotlin.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
        </div>
    </div>

    <!--Глава 4-->
    <div id="chapter-4" class="chapter">
        <h1 class="collapsible">Глава 4. </h1>
        <div>
            <h2>Введение</h2>
            <p>Функции являются строительными блоками любого кода. Они помогают сделать наши программы более модульными,
                безопасными и простыми для понимания. Функции имеют решающее значение в объектно-ориентированном
                программировании, поскольку они играют важную роль в абстракции и инкапсуляции (два очень важных
                принципов проектирования). Kotlin приносит много новшевств в то, как мы используем функции. Это
                облегчает функциональное программирование с помощью сцепления и лямбд. В этой главе мы узнаем рецепты,
                которые помогут нам работать с функциями. Итак, давайте приступим к работе!</p>
            <hr>
            <!--Рецепт-->
            <div id="receipt-4_1" class="receipt">
                <h2 class="collapsible">Задание значений по умолчанию в функциях</h2>
                <div>
                    <p>Если вы пришли из мира Java, вы можете помнить, что для методов, мы не можем указать значение по
                        умолчанию. Это означает, что мы не можем сделать что-то подобное в Java:</p>
                    <pre>public void foo(int a, int b=10){}</pre>
                    <p>Нам нужно написать два метода для этого, это известно как <em>перегрузка</em> метода:</p>
                    <pre>public void foo(int a){}
public void foo(int a, int b){}</pre>
                    <p>Теперь, предположим, что у вас есть функция с тремя различными типами параметров, такими как:</p>
                    <pre>public void foo (int a,double b, String c){}</pre>
                    <p>Тогда у вас будет семь экземпляров перегрузки метода:</p>
                    <pre>public void foo (int a,double b, String c),
public void foo (int a,double b) ,
public void foo (double b, String c),
public void foo (int a, String c),
public void foo (int a),
public void foo (double b),
public void foo (String c)</pre>
                    <p>Kotlin предоставляет вамвозможность указывать значения по умолчанию в методах, с помощью которых
                        вы можете предотвратить безумное количество перегрузок метода. Некоторые люди могут сказать,
                        "Эй, почему бы нам не использовать шаблон Builder вместо перегрузки методов?". Эти люди правы,
                        но Kotlin-путь проще. Давайте посмотрим!</p>
                    <h3>Подготовка</h3>
                    <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода. Вы можете
                        использовать любую удобную для вас среду разработки.</p>
                    <h3>Как это сделать...</h3>
                    <p>В Kotlin, параметры функций могут иметь значения по умолчанию, и они используются если
                        соответствующий аргумент опущен. Это, уменьшает число перегрузок метода. Предыдущий пример с
                        тремя различными типами параметров может быть легко решен в Kotlin гораздо меньшим количеством
                        кода:</p>
                    <ol>
                        <li>Добавим указанный код в редактор, запустим его и проверим вывод:
                            <pre>fun main(args: Array&lt;String&gt;) {
    foo()
    foo(1)
    foo(1,0.1)
    foo(1,0.1,"custom string")
}

fun foo(a:Int=0, b: Double =0.0, c:String="some default value"){
    println("a=$a , b=$b ,c = $c")
}</pre>
                            <p>При выполнении предыдущего кода Вы увидите следующий вывод:</p>
                            <pre>Output:
a=0 , b=0.0 ,c = some default value
a=1 , b=0.0 ,c = some default value
a=1 , b=0.1 ,c = some default value
a=1 , b=0.1 ,c = custom string</pre>
                        </li>
                        <li>Как вы можете видеть, нам не нужно было реализовывать четыре разных метода, и мы смогли
                            сопоставить аргументы. Параметры по умолчанию используются, когда мы вызываем методы, не
                            предоставляя явные параметры, поэтому, когда вы не передаете никаких параметров, он просто
                            использует все параметры по умолчанию. С помощью именованных аргументов можно еще больше
                            уменьшить количество методов, но об этом мы расскажем в следующем рецепте.
                        </li>
                        <li>Следует отметить, что аргументы по умолчанию также будут работать и в конструкторах. Таким
                            образом, вы можете объявить класс следующим образом:
                            <pre>data class Event(var eventName: String? = "", var eventSchedule: Date? = Date(), var isPrivate: Boolean = false)</pre>
                            <p><em>Чтобы узнать больше о классе данных, перейдите к Главе 11, рецепт: Как создать класс
                                данных в Kotlin.</em></p>
                        </li>
                        <li>Затем мы можем объявить объекты, как показано:
                            <pre>Event("Celebration")
Event("Ceberation", Date())
Event("Ceberation", Date(), true)</pre>
                            <p>Как вы Видите, с помощью значений по умолчанию в конструкторах, мы избегаем необходимости
                                реализации нескольких конструкторов, которые мы использовали в Java.</p>
                            <p>Помните, что здесь есть нюанс. Мы не сможем этого сделать, если вы создаете объекты
                                Java. Это означает, что выполнение действий, показанных в следующем коде, не будет
                                приниматься Java. Я знаю, что вы скажете: "А как же 100% совместимость с Java ?!":</p>
                            <pre>new Event("Celebration")
new Event("Celebration", Date())
new Event("Celebration", Date(), true)</pre>
                        </li>
                        <li>Если мы хотим предоставить многократные перегрузки вызывающим объектам Java, нам просто
                            нужно сделать небольшую модификацию, добавить <code>@JvmOverloads</code> к конструкторам и
                            функциям со значениями по умолчанию так, чтобы предыдущее объявление класса стало таким:
                            <pre>data class Event @JvmOverloads constructor (var eventName: String? = "", var date: Date? = Date(), var isPrivate: Boolean = false)</pre>
                        </li>
                        <li>Кроме того, наш метод становится таким:
                            <pre>@JvmOverloads fun foo(a:Int=0, b: Double =0.0, c:String="some default value"){ println("a=$a , b=$b ,c = $c") }</pre>
                        </li>
                    </ol>
                    <p>Это небольшая цена, но аннотация <code>@JvmOverloads</code> помогает нашим конструкторам и
                        функциям иметь
                        значения по умолчанию, вызываемые из мира Java.</p>
                    <h3>Это еще не все...</h3>
                    <p>Если мы хотим, чтобы наш код работал только в мире Kotlin, то нам не нужна аннотация <code>@JvmOverloads</code>,
                        потому что у Kotlin есть свои правила, по которым он может работать со значениями по умолчанию в
                        конструкторах и функциях. Добавление аннотации <code>@JvmOverloads</code> создает все
                        необходимые перегрузки. Поэтому, если вы декомпилируете байт-код Kotlin, вы увидите все
                        перегруженные версии конструкторов и функций.</p>
                    <p><a href="index.html#content-book">К содержанию...</a></p>
                    <hr>
                </div>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_2" class="receipt">
                <h2 class="collapsible">Использование именованных аргументов в функциях</h2>
                <p>Этот рецепт можно рассматривать как расширение предыдущего рецепта, связанного с значениями по
                    умолчанию в функциях. Параметры по умолчанию и именованные аргументы в функции, вместе могут сильно
                    снизить количество перегрузок метода. Мы уже видели, как использовать параметры по умолчанию в
                    функции, теперь давайте посмотрим, как использовать именованные аргументы.</p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода. Вы можете использовать
                    любую удобную для вас среду разработки.</p>
                <h3>Как это сделать...</h3>
                <p>Еще одним шагом к уменьшению числа перегрузок и повышению читаемости кода является использование
                    именованных аргументов. Давайте рассмотрим следующий код:</p>
                <ol>
                    <li>В том же примере функции <code>foo</code> мы можем использовать именованные аргументы:
                        <pre>fun main(args: Array&lt;String&gt;) {
    foo(b = 0.9)
    foo(a = 1, c = "Custom string")
}

fun foo(a: Int = 0, b: Double = 0.0, c: String = "some default value"){
    println("a = $a , b = $b ,c = $c")
}</pre>
                    </li>
                    <li>Это выходные данные, которые вы получите, выполнив предыдущий код:
                        <pre>Output:
a = 0 , b = 0.9 ,c = some default value
a = 1 , b = 0.0 ,c = Custom string</pre>
                    </li>
                    <li>Именованные аргументы предотвращают перегрузку, а также делают код более читабельным. Кроме
                        того, нам не нужно приводить все аргументы. Я имею в виду, что если бы у вас было два параметра
                        <code>a</code> и <code>c</code>, тогда вам нужно было бы сделать что-то вроде этого:
                        <pre>foo(1, 0.0, "Custom string")</pre>
                    </li>
                    <li>Вы должны добавить значение по умолчанию, чтобы заполнить пространство между <code>a</code> и
                        <code>c</code>. Однако с именованными аргументами вы можете использовать <code>foo(a = 1, c =
                            "Custom string")</code> без использования аргументов по умолчанию между ними.
                    </li>
                    <li>Важно отметить, что при вызове функции как с позиционными, так и с именованными аргументами
                        позиционные аргументы должны располагаться перед первым именованным аргументом. Например,вызов
                        <code>foo(1, b = 0.1)</code> - разрешен, а вызов <code>foo(A = 1, 0.1)</code> - нет.
                    </li>
                </ol>
                <p>Значения по умолчанию и именованные аргументы могут свести к минимуму необходимое количество
                    перегрузок, делая размер кода небольшим и повышая его читаемость.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_3" class="receipt">
                <h2 class="collapsible">Создание адаптера RecyclerView в Kotlin</h2>
                <p><code>RecyclerView</code> является одним из наиболее широко используемых элементов в разработке
                    Android. Он в основном используется для отображения данных в списке с помощью адаптера. В этом
                    рецепте мы узнаем, как использовать Kotlin, чтобы сделать <code>RecyclerView</code> гораздо более
                    эффективным. Мы также будем использовать <code>DiffUtils</code>. Он доступен с 24.02. Согласно
                    документации:</p>
                <q><em>Diffutil - это служебный класс, который может вычислять разницу между двумя списками и выводить
                    список операций обновления, преобразующих первый список во второй.</em></q>
                <p>Определение не требует пояснений. <code>NotifyDatasetChanged</code> является очень дорогой операцией
                    адаптера. <code>DiffUtils</code> только обновляет части, которые были изменены, в отличие от <code>notifyDatasetChanged</code>,
                    который обновляет весь список.</p>
                <h3>Подготовка</h3>
                <p>Создайте новый проект Android в Android Studio. Вы также можете клонировать
                    <a href="https://gitlab.com/aanandshekharroy/kotlin-cookbook" target="_blank">репозиторий</a>, ветка
                    <code>1-recyclerview-in-kotlin</code>. В этом приложении, мы будем создавать простой список
                    различных Android вкусов, выпущенных Google, что-то вроде того, что видели здесь:</p>
                <img src="img/23.png" alt="">
                <p>Как вы можете видеть, есть плавающая кнопка действия, нажатие на нее обновит порядок списка. Мы будем
                    обновлять список <code>RecyclerView</code>, но мы будем обновлять его с помощью
                    <code>DiffUtils</code> вместо метода <code>notifyDatasetChanged</code>.</p>
                <h3>Как это сделать...</h3>
                <p>Итак, давайте теперь выполним следующие действия, чтобы создать приложение, которое мы только что
                    обсудили:</p>
                <ol>
                    <li>Во-первых, нам нужно создать список вкусов Android. Итак, мы сначала создадим класс данных,
                        который содержит изображение и имя вкуса:
                        <pre>data class AndroidFlavours (var name: String, val image: Int)</pre>
                        <p>Мы определили тип изображения как <code>Int</code>, потому что мы будем использовать
                            идентификаторы изображений. В папке <code>drawable</code> мы будем хранить все необходимые
                            изображения.</p>
                    </li>
                    <li>Далее мы создадим список Android-вкусов:
                        <pre>val flavorList= listOf&lt;AndroidFlavours&gt;(
    AndroidFlavours("Cupcake",R.drawable.cupcake),
    AndroidFlavours("Donut",R.drawable.donut),
    AndroidFlavours("Eclair",R.drawable.eclair),
    AndroidFlavours("Froyo",R.drawable.froyo),
    AndroidFlavours("Gingerbread",R.drawable.gingerbread),
    AndroidFlavours("HoneyComb",R.drawable.honeycomb),
    AndroidFlavours("Icecream Sandwich",R.drawable.icecream),
    AndroidFlavours("Jellybean",R.drawable.jellybean),
    AndroidFlavours("KitKat",R.drawable.kitkat),
    AndroidFlavours("Lollipop",R.drawable.lollipop)
)</pre>
                    </li>
                    <li>Теперь мы создадим адаптер. Назовем его <code>AndroidFlavourAdapter</code>:
                        <pre>class AndroidFlavourAdapter: RecyclerView.Adapter&lt;AndroidFlavourAdapter.FlavourViewHolder&gt;() {

    var flavourItems: List&lt;AndroidFlavours&gt; by Delegates.observable(emptyList()) { property, oldValue, newValue -> notifyChanges(oldValue,newValue) }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): FlavourViewHolder = FlavourViewHolder(parent.inflate(R.layout.flavour_item))
    override fun getItemCount(): Int = flavourItems.size
    override fun onBindViewHolder(holder: FlavourViewHolder, position: Int) {
        holder.name.text = flavourItems.get(holder.adapterPosition).name
        holder.image.loadImage(flavourItems.get(holder.adapterPosition).image)
    }

    inner class FlavourViewHolder(var view: View): RecyclerView.ViewHolder(view){
        var name:TextView = view.findViewById(R.id.textView)
        var image:ImageView = view.findViewById(R.id.imageView)
    }
}</pre>
                        <p>Предыдущий код вполне стандартен для общей реализации <code>RecyclerView</code>, за
                            исключением двух вещей. Одним из них является функция <code>loadImage</code>, которая не
                            является собственной функцией, а функцией-расширением, реализация которой такова:</p>
                        <pre>fun ImageView.loadImage(image: Int) { Glide.with(context).load(image).into(this) }</pre>
                    </li>
                    <li>Другое дело, что мы определили список <code>AndroidFlavours</code> в адаптере. <code>flavoursList</code>
                        в адаптере является наблюдаемым (<code>observable</code>) свойством. Это означает, что слушатель
                        получает уведомление об изменениях этого свойства. Следовательно, мы получаем следующую
                        конструкцию:
                        <pre>var flavourItems: List&lt;AndroidFlavours&gt; by Delegates.observable(emptyList()) { property, oldValue, newValue -> notifyChanges(oldValue,newValue) }</pre>
                    </li>
                    <li>Теперь, всякий раз, когда мы пытаемся присвоить значение переменной <code>flavourItems</code>,
                        выполняется код в блоке <code>{ .. }</code>, в которм есть старые и новые значения, чтобы
                        сделать операцию, если мы хотим. В этом случае мы сделаем это с помощью метода <code>notifyChanges</code>.
                        Давайте посмотрим на метод <code>notifyChanges</code>:
                        <pre>private fun notifyChanges(oldValue: List&lt;AndroidFlavours&gt;, newValue: List&lt;AndroidFlavours&gt;) {
    val diff = DiffUtil.calculateDiff(object : DiffUtil.Callback() {
        override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {

            val oldFlavor=oldValue.get(oldItemPosition)
            val newFlavor=newValue.get(newItemPosition)
            val bundle=Bundle()

            if(!oldFlavor.name.equals(newFlavor.name)){
                bundle.putString("name",newFlavor.name)
            }

            if(!oldFlavor.image.equals(newFlavor.image)){
                bundle.putInt("image",newFlavor.image)
            }

            if(bundle.size() == 0) return null

            return bundle
        }

        override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean = oldValue.get(oldItemPosition) == newValue.get(newItemPosition)
        override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
            return oldValue.get(oldItemPosition).name.equals(newValue.get(newItemPosition).name) && oldValue.get(oldItemPosition).image.equals(newValue.get(newItemPosition).image)
        }
        override fun getOldListSize() = oldValue.size
        override fun getNewListSize() = newValue.size
    })

    diff.dispatchUpdatesTo(this)
}</pre>
                        <p>Я объясню предыдущий код в следующем разделе.</p>
                    </li>
                    <li>Теперь давайте настроим адаптер:
                        <pre>mAdapter = AndroidFlavourAdapter()
flavour_list.layoutManager = LinearLayoutManager(this)
flavour_list.adapter = mAdapter
mAdapter.flavourItems = flavorList
shuffle.setOnClickListener { mAdapter.flavourItems=flavorList.shuffle() }</pre>
                    </li>
                    <li>Функция <code>shuffle</code> случайным образом отсортирует список <code>AndroidFlavours</code>,
                        перемешает его. Функция <code>.shuffle()</code> не является функцией Kotlin или Java, а является
                        функцией-расширением:
                        <pre>fun &lt;E&gt; List&lt;E&gt;.shuffle(): MutableList&lt;E&gt; {
    val list = this.toMutableList()
    Collections.shuffle(list)
    return list
}</pre>
                    </li>
                </ol>
                <h3>Как это работает...</h3>
                <p>Давайте погрузимся в <code>DiffUtils</code>. <code>DiffUtils</code> требует два массива/списка, один
                    из которых должен быть старым списком, и другой должен быть новым списком.</p>
                <p>Существует пять основных функций:</p>
                <ul>
                    <li><code>getNewListSize()</code>: Возвращает размер нового списка.</li>
                    <li><code>getOldListSize()</code>: Возвращает размер старого списка.</li>
                    <li><code>areItemsTheSame()</code>: Определяет, представляют ли два объекта один и тот же элемент.
                    </li>
                    <li><code>areContentsTheSame()</code>: Метод используется для определения того, содержат ли два
                        объекта одинаковые данные. В нашей реализации мы возвращаем true, если оба объекта имеют
                        одинаковое имя и изображение.
                    </li>
                    <li><code>getChangePayload()</code>: Когда <code>areItemsTheSame()</code> возвращает
                        <code>true</code>, а <code>areContentsTheSame()</code> возвращает <code>false</code>, то <code>DiffUtils</code>
                        вызывает этот метод, чтобы получить изменения.
                    </li>
                </ul>
                <p>В нашей реализации предыдущего метода мы добавляем изменение имени и изображения в полезные
                    данные:</p>
                <pre>override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {

    val oldFlavor=oldValue.get(oldItemPosition)
    val newFlavor=newValue.get(newItemPosition)
    val bundle=Bundle()

    if(!oldFlavor.name.equals(newFlavor.name)){
         bundle.putString("name",newFlavor.name)
    }

    if(!oldFlavor.image.equals(newFlavor.image)){
        bundle.putInt("image",newFlavor.image)
    }

    if(bundle.size() == 0) return null

    return bundle
}</pre>
                <p>Наконец, после вычисления различий объект <code>DiffUtils</code> отправляет изменения адаптеру. Для
                    этого мы вызываем метод <code>dispatchUpdatesTo</code>:</p>
                <pre>diff.dispatchUpdatesTo(this)</pre>
                <p>Чтобы обновить изменения из полезных данных, необходимо переопределить <code>onBindViewHolder(
                    holder: FlavourViewHolder, position: Int, payloads: MutableList&lt;Any&gt;? )
                </code>:</p>
                <pre>override fun onBindViewHolder(holder: FlavourViewHolder, position: Int, payloads: MutableList&lt;Any&gt;?) {
    if (payloads != null) {
        if (payloads.isEmpty())
            return onBindViewHolder(holder,position)
        } else {
            val o = payloads.get(0) as Bundle
            for (key in o.keySet()) {
                if (key == "name") {
                    holder.name.text=o.getString("name")
                } else if (key == "image") {
                    holder.image.loadImage(o.getInt("image"))
                }
            }
        }
    }
}</pre>
                <p>Изменения полезных данных отправляются с помощью метода <code>notifyItemRangeChanged</code> адаптера.
                </p>
                <h3>Это еще не все...</h3>
                <p>В документации указано, что обработка различий между двумя списками может занять некоторое время,
                    если списки слишком велики, поэтому это должно выполняться в фоновом потоке, например, с помощью
                    <code>RxJava</code>.</p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_4" class="receipt">
                <h2 class="collapsible">Создание геттеров и сеттеров in Kotlin</h2>
                <p>Если вы работали с Java, то наверняка знаете, что такое <em>геттер-сеттер</em>. Java имеет поля, и
                    геттеры-сеттеры являются методами, которые используются, чтобы <strong>получить</strong>(геттер) и
                    <strong>изменить</strong>(сеттер) переменные-члены. Они являются неотъемлемой частью инкапсуляции
                    (один из принципов проектирования).</p>
                <p>Однако в Kotlin у нас нет полей, зато есть <strong>свойства</strong>. Свойство может иметь
                    пользовательскую реализацию метода <strong>получения</strong> и <strong>изменения</strong>. В этом
                    рецепте мы увидим, как можно реализовать пользовательские методы доступа и изменения.</p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода. Вы можете использовать
                    любую удобную для вас среду разработки.</p>
                <h3>Как это сделать...</h3>
                <p>Чтобы понять, как работают пользовательские геттер-сеттеры в Kotlin, выполните следующие
                    действия:</p>
                <ol>
                    <li>Синтаксис <strong>свойства</strong> Kotlin выглядит следующим образом:
                        <pre>var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;][&lt;getter&gt;] [&lt;setter&gt;]</pre>
                        <p>Поэтому, если вы используете что-то вроде <code>val a = 1</code>, Вы получаете геттер и
                            сеттер по умолчанию.</p>
                    </li>
                    <li>Теперь, давайте посмотрим, как мы можем создать пользовательский геттер. Предположим, у нас есть
                        свойство, значение которого зависит от другого свойства:
                        <pre>fun main(args: Array&lt;String&gt;) {
    val sample=Sample()
    println(sample.isListBig)
}

class Sample{
    val array = mutableListOf&lt;Int&gt;(1, 2, 3)
    val isListBig: Boolean
        get() = array.size &gt; 2
}</pre>
                        <p>Если вы запустите предыдущий код, вы увидите в консоли следующие выходные данные:</p>
                        <img src="img/24.png" alt="">
                    </li>
                    <li>Как вы можете видеть, мы можем изменить геттер в методе <code>get</code> свойства. Если тип
                        свойства выводится из метода получения, мы также можем сделать это:
                        <pre>val isListBig get() = array.size > 2</pre>
                        <p>Результат будет конечно тот же.</p>
                    </li>
                </ol>
                <p>Теперь давайте взглянем на сеттеры:</p>
                <ol>
                    <li>В Java мы делали что-то вроде:
                        <pre>public setIsListBig(boolean isListBig){
    this.isListBig = isListBig
}</pre>
                    </li>
                    <li>Если мы попытаемся осуществить это в Kotlin, это будет выглядеть примерно так:
                        <p><img src="img/25.png" alt=""></p>
                    </li>
                    <li>Как вы можете видеть, мы получим предупреждение от IDE о том, что это рекурсивный вызов. Почему?
                        Потому что, когда вы пытаетесь установить значение с помощью <code>.isListBig</code>, вы уже
                        используете сеттер внутри сеттера, получается рекурсивный цикл.
                    </li>
                    <li>Для того, чтобы уйти от этого рекурсивного вызова и реализовать сеттер, вам нужно ключевое слово
                        <code>field</code>. Таким образом, предыдущая реализация будет выглядеть примерно так:
                        <pre>var isListBig :Boolean = false
    set(value) {
        field = array.size>2
    }</pre>
                    </li>
                    <li>При инициализации <code>isListBig</code> при объявлении свойства значение присваивается
                        резервному полю без вызова метода установки. Ключевое слово <code>field</code> используется для
                        доступа к резервному полю и будет сгенерировано для свойства, если оно использует реализацию по
                        умолчанию хотя бы одного метода доступа или если пользовательский метод доступа ссылается на
                        него через идентификатор <code>field</code>.
                    </li>
                    <li>Если вы хотите ограничить доступ к сеттеру, это можно сделать следующим образом:
                        <pre>var isListBig :Boolean = false
    private set(value) {
        field = array.size > 2
    }</pre>
                    </li>
                    <li>Кроме того, предположим, что используется своего рода инъекция зависимостей. Вы можете сделать
                        это так:
                        <pre>var mPresenter: MainActivityMvpPresenter? = null
    @Inject set</pre>
                    </li>
                    <li>Подобно <code>set</code>, у вас также может быть пользовательская реализация <code>get</code>.
                        Давайте рассмотрим пример:
                        <pre>class SameClass {
    var name = "aanand"
        get() = field.toUpperCase()
    }</pre>
                    </li>
                    <li>Теперь предположим, что мы пытаемся получить доступ к свойству name:
                        <pre>fun main(args: Array&lt;String&gt;) {
    var s = SameClass()
    println(s.name)
}</pre>
                    </li>
                </ol>
                <p>Если вы запустите предыдущий код, вы увидите следующие выходные данные:</p>
                <img src="img/26.png" alt="">
                <p>Обратите внимание, что мы также использовали <code>field</code> в методе <code>get()</code>. Это то
                    самое резервное поле, которое мы объяснили ранее.</p>
                <h3>Это еще не все...</h3>
                <p>Здесь следует отметить, что нельзя реализовать пользовательский геттер или сеттер для свойства в
                    конструкторе. Необходимо объявить свойство в теле класса:</p>
                <pre>class Student(val name: String, age: Int) {
    var age: Int = age
    set(value) {
        println("Setting age to $value")
        field = value
    }
}</pre>
                <p>Ещё одна ключевая вещь, которую следует отметить, заключается в том, что вам нужно сохранить
                    видимость геттера точно такой же, как видимость свойства:</p>
                <pre>protected var name="aanand"
protected get() = field.toUpperCase()</pre>
                <p>Предыдущий код вполне допустим, хотя и излишне снова размещать один и тот же модификатор доступа,
                    поэтому лучше его опустить.</p>
                <p>Сеттер, с другой стороны, может иметь модификатор доступа менее доступный, чем свойство. Рассмотрим
                    пример:</p>
                <pre>protected var name="aanand"
    private set</pre>
                <p>Предыдущий код допустим, поскольку модификатор доступа сеттера <code>private</code> является менее
                    допустимым, чем модификатор доступа свойства:</p>
                <pre>protected var name="aanand"
    public set</pre>
                <p>Однако предыдущий код является недопустимым, поскольку <code>protected</code> является менее
                    разрешительным, чем <code>public</code></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_5" class="receipt">
                <h2 class="collapsible">Передача переменного числа аргументов в функцию</h2>
                <p>Есть много сценариев, в которых мы должны передать переменное число аргументов в функцию. В Kotlin
                    это можно сделать с помощью модификатора vararg. В этом рецепте, мы рассмотрим все. Мы рассмотрим
                    несколько примеров, чтобы продемонстрировать, как использовать эту функцию Kotlin.</p>
                <h3>Подготовка</h3>
                <p>Необходимо установить среду разработки, которая компилирует и запускает Kotlin. Для этой цели можно
                    также использовать командную строку, для этого необходимо установить компилятор Kotlin вместе с JDK.
                    Я использую онлайн IDE, доступное по адресу <a href="https://try.kotlinlang.org" target="_blank">https://try.kotlinlang.org</a>
                    или <a href="https://play.kotlinlang.org/" target="_blank">https://play.kotlinlang.org</a> для
                    компиляции и запуска кода Kotlin для этого рецепта. Вы также можете использовать среду разработки
                    IntelliJ IDEA.</p>
                <h3>Как это сделать...</h3>
                <p>Давайте рассмотрим следующие шаги, где мы покажем, как передать переменное количество аргументов функции:</p>
                <ol>
                    <li><pre></pre></li>
                    <li><pre></pre></li>
                    <li><pre></pre></li>
                    <li><pre></pre></li>
                    <li><pre></pre></li>
                    <li><pre></pre></li>
                    <li><pre></pre></li>
                </ol>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_6" class="receipt">
                <h2 class="collapsible">Передача функции в качестве параметра другой функции</h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_7" class="receipt">
                <h2 class="collapsible">Объявление статической функции</h2>
                <p></p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода. Вы можете использовать
                    любую удобную для вас среду разработки. Мы будем изучать статические функции.</p>
                <h3>Как это сделать...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_8" class="receipt">
                <h2 class="collapsible">Использование ключевого слова use в Kotlin</h2>
                <p></p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода. Вы можете использовать
                    любую удобную для вас среду разработки.</p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_9" class="receipt">
                <h2 class="collapsible">Работа с замыканиями</h2>
                <p></p>
                <h3>Подготовка</h3>
                <p>Мы будем использовать IntelliJ IDEA для написания и выполнения нашего кода. Вы можете использовать
                    любую удобную для вас среду разработки.</p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_10" class="receipt">
                <h2 class="collapsible">Литералы функций с приемниками</h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-4_11" class="receipt">
                <h2 class="collapsible">Работа с анонимными функциями</h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
        </div>
    </div>

    <!--Глава -->
    <div id="chapter-" class="chapter">
        <h1 class="collapsible">Глава . </h1>
        <div>
            <h2>Введение</h2>
            <p></p>
            <hr>
            <!--Рецепт-->
            <div id="receipt-_1" class="receipt">
                <h2 class="collapsible"></h2>
                <div>
                    <p></p>
                    <h3>Подготовка</h3>
                    <p></p>
                    <h3>Как это сделать...</h3>
                    <p></p>
                    <h3>Как это работает...</h3>
                    <p></p>
                    <h3>Это еще не все...</h3>
                    <p></p>
                    <h3>См. также...</h3>
                    <p></p>
                    <p><a href="index.html#content-book">К содержанию...</a></p>
                    <hr>
                </div>
            </div>
            <!--Рецепт-->
            <div id="receipt-_2" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_3" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_4" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_5" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_6" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_7" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_8" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_9" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_10" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_11" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_12" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
            <!--Рецепт-->
            <div id="receipt-_13" class="receipt">
                <h2 class="collapsible"></h2>
                <p></p>
                <h3>Подготовка</h3>
                <p></p>
                <h3>Как это сделать...</h3>
                <p></p>
                <h3>Как это работает...</h3>
                <p></p>
                <h3>Это еще не все...</h3>
                <p></p>
                <h3>См. также...</h3>
                <p></p>
                <p><a href="index.html#content-book">К содержанию...</a></p>
                <hr>
            </div>
        </div>
    </div>


</div>

</body>
<!--<script src="main.js"></script>-->
</html>

            






